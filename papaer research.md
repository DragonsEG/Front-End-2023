



`      `"This machine is a server. DO NOT POWER IT DOWN!!" Do you Want to Know the Story let go TO know let us to start first we talk about the web we are go to know when and how the web born in the button of the next page we talk about the web and how start we talk also about who elements render in the browser and what mean SSR and CSR and what we use in our days (hybrid)what is example for hybrid and other we talk about the problems which solved by react such multiable media  firstly perhaps you ask yourself what is react and why react but let us in our topic and we cover this point in later what is framework and what is the benefit from it what difference between framework and library and who both work vice-verse the another also principles of react and design in react  We will address it later we will cover the client-side VS server-side and pros and cons of each of them we talk about react mechanism of rendering what is the DOM and virtual DOM and advantages and disadvantages  we will see React VS jQuery and beyond the browser and react for multi platforms
## **Where the Web was born
Tim Berners-Lee, a British scientist, invented the World Wide Web (WWW) in 1989, while working at CERN. The Web was originally conceived and developed to meet the demand for automated information-sharing between scientists in universities and institutes around the world.

CERN is not an isolated laboratory, but rather the focal point for an extensive community that includes more than 17 000 scientists from over 100 countries. Although they typically spend some time on the CERN site, the scientists usually work at universities and national laboratories in their home countries. Reliable communication tools are therefore essential.

The basic idea of the WWW was to merge the evolving technologies of computers, data networks and hypertext into a powerful and easy to use global information system

How the Web began

Tim Berners-Lee wrote the first proposal for the World Wide Web in March 1989 and his [second proposal in May 1990](http://cds.cern.ch/record/369245/files/dd-89-001.pdf). Together with Belgian systems engineer Robert Cailliau, this was formalised as [a management proposal](http://cds.cern.ch/record/2639699/files/Proposal_Nov-1990.pdf) in November 1990. This outlined the principal concepts and it defined important terms behind the Web. The document described a "hypertext project" called "WorldWideWeb" in which a "web" of "hypertext documents" could be viewed by “browsers”.

By the end of 1990, Tim Berners-Lee had the first Web server and browser up and running at CERN, demonstrating his ideas. He developed the code for his Web server on a NeXT computer. To prevent it being accidentally switched off, the computer had a hand-written label in red ink: "This machine is a server. DO NOT POWER IT DOWN!!"




Do you want to know what is the first website in the world follow us: [info.cern.ch](http://info.cern.ch/) was the address of the world's first website and Web server, running on a NeXT computer at CERN. The first Web page address was <http://info.cern.ch/hypertext/WWW/TheProject.html>

This page contained links to information about the WWW project itself, including a description of hypertext, technical details for creating a Web server, and links to other Web servers as they became available.

The WWW design allowed easy access to existing information and an [early web page](http://info.cern.ch/NextBrowser.html) linked to information useful to CERN scientists (e.g. the CERN phone book and guides for using CERN’s central computers). A search facility relied on keywords - there were no search engines in the early years.

Berners-Lee’s original Web browser running on NeXT computers showed his vision and had many of the features of current Web browsers. In addition, it included the ability to modify pages from directly inside the browser – the first Web editing capability. This screenshot shows the [browser running on a NeXT computer in 1993](http://info.cern.ch/NextBrowser1.html)
## The Web extends
Only a few users had access to a NeXT computer platform on which the first browser ran, but development soon started on a simpler, [‘line-mode’ browser](http://line-mode.cern.ch/), which could run on any system. It was written by Nicola Pellow during her student work placement at CERN.

In 1991, Berners-Lee released his WWW software. It included the ‘line-mode’ browser, Web server software and a library for developers. In March 1991, the software became available to colleagues using CERN computers. A few months later, in August 1991, he [announced the WWW software on Internet newsgroups](https://www.w3.org/People/Berners-Lee/1991/08/art-6484.txt) and interest in the project spread around the world.

The web are going to be globally and it is going to dominant

If you ask how the web become as we know to-day see us in the next page


## Going global
Thanks to the efforts of Paul Kunz and Louise Addis, the first Web server in the US came online in December 1991, once again in a particle physics laboratory: the [Stanford Linear Accelerator Center](http://www.slac.stanford.edu/history/earlyweb/history.shtml) (SLAC) in California. At this stage, there were essentially only two kinds of browser. One was the original development version, which was sophisticated but available only on NeXT machines. The other was the ‘line-mode’ browser, which was easy to install and run on any platform but limited in power and user-friendliness. It was clear that the small team at CERN could not do all the work needed to develop the system further, so Berners-Lee launched a plea via the internet for other developers to join in. Several individuals wrote browsers, mostly for the X-Window System. Notable among these were MIDAS by Tony Johnson from SLAC, Viola by Pei Wei from technical publisher O'Reilly Books, and Erwise by Finnish students from Helsinki University of Technology.

Early in 1993, the [National Center for Supercomputing Applications](http://www.ncsa.illinois.edu/) (NCSA) at the University of Illinois released a first version of its Mosaic browser. This software ran in the X Window System environment, popular in the research community, and offered friendly window-based interaction. Shortly afterwards the NCSA released versions also for the PC and Macintosh environments. The existence of reliable user-friendly browsers on these popular computers had an immediate impact on the spread of the WWW. The European Commission approved its first web project (WISE) at the end of the same year, with CERN as one of the partners. On 30 April 1993, CERN made the source code of WorldWideWeb available on a royalty-free basis, making it free software. By late 1993 there were over 500 known web servers, and the WWW accounted for 1% of internet traffic, which seemed a lot in those days (the rest was remote access, e-mail and file transfer). 1994 was the “Year of the Web”. Initiated by Robert Cailliau, [the First International World Wide Web conference](http://www94.web.cern.ch/WWW94/Welcome0522.html) was held at CERN in May. It was attended by [380 users and developers](http://www94.web.cern.ch/WWW94/Welcome.html), and was hailed as the “Woodstock of the Web”.

As 1994 progressed, stories about the Web hit the media. A second conference, attended by 1300 people, was held in the US in October, organised by the NCSA and the newly-formed [International WWW Conference Committee](http://www.iw3c2.org/conferences) (IW3C2). By the end of 1994, the Web had 10 000 servers - 2000 of which were commercial - and 10 million users. Traffic was equivalent to shipping the entire collected works of Shakespeare every second. The technology was continually extended to cater for new needs. Security and tools for e-commerce were the most important features soon to be added.
## Open standards
An essential point was that the web should remain an open standard for all to use and that no-one should lock it up into a proprietary system. In this spirit, CERN submitted a proposal to the Commission of the European Union under the ESPRIT programme: “WebCore”. The goal of the project was to form an international consortium, in collaboration with the US Massachusetts Institute of Technology (MIT). In 1994, Berners-Lee left CERN to join MIT and founded the [International World Wide Web Consortium](http://www.w3c.org/) (W3C). Meanwhile, with approval of the LHC project clearly in sight, CERN decided that further web development was an activity beyond the laboratory’s primary mission. A new European partner for W3C was needed.

The European Commission turned to the French National Institute for Research in Computer Science and Controls (INRIA), to take over CERN's role. In April 1995, INRIA became the first European W3C host, followed by [Keio University of Japan](http://www.keio.ac.jp/) (Shonan Fujisawa Campus) in Asia in 1996. In 2003, [ERCIM (European Research Consortium in Informatics and Mathematics)](http://www.ercim.org/) took over the role of European W3C Host from INRIA. In 2013, W3C [announced](http://www.w3.org/2013/01/china-host.html.en) [Beihang University](http://ev.buaa.edu.cn/) as the fourth Host. In September 2018, there were [more than 400 member organisations](https://www.w3.org/Consortium/Member/List) from around the world. After we speak about the web let we start in the render elements in the web and what the difference between past and present and what will be in the future let we see in the next page how it will explain for us what is SSR and what is CSR


# The Evolution of Content Rendering on Websites: Past, Present, and Future
When it comes to building websites, one of the most critical decisions developers face is how to handle content rendering. From server-side rendering (SSR) to client-side rendering (CSR) and hybrid rendering, the choices can be overwhelming. In this blog post, we'll explore the past, present, and future of content rendering on websites.
## **The Past: Server-Side Rendering**
In the early days of the internet, websites were primarily built using SSR technologies such as PHP. With SSR, the server generates the HTML for the page and sends it to the client's browser for rendering. This approach worked well for simple websites that didn't require dynamic updates or complex user interactions.

One of the key benefits of SSR is that it enables websites to function well on a wide range of devices, including those with limited processing power or slow internet connections. This is because the server does most of the heavy lifting in generating the HTML, meaning that the client device doesn't need to have a powerful processor or fast internet connection to load the page quickly.

However, as websites became more complex, the limitations of SSR became apparent. Pages that required frequent updates or user interactions were difficult to implement with SSR, leading to the rise of client-side rendering.
### Pros of SSR
- Fast initial page load times: SSR allows the server to send the complete HTML page to the client, enabling faster load times compared to CSR.
- Better SEO: Since the server generates the complete HTML page, it's easier for search engine crawlers to index the page and improve its visibility on search engine result pages.
- Good for simple, static sites: SSR is an ideal approach for websites that don't have complex interactions or dynamic content.
### Cons of SSR
- Limited interactivity: Since most of the rendering is done on the server side, SSR is not ideal for websites that require frequent updates or complex user interactions.
- Resource-intensive: SSR can be resource-intensive on the server, especially for websites with a large number of pages or concurrent users.
### Examples of SSR
- WordPress: WordPress is an example of a content management system (CMS) that uses SSR to render web pages.
- Ruby on Rails: Ruby on Rails is a web application framework that uses SSR by default.
## **The Present: Client-Side Rendering**
With client-side rendering, the server sends the raw data to the client, and JavaScript is used to render the page on the client side. This allows for a more interactive user experience and better performance, as the server only needs to send data rather than generating entire HTML pages. Technologies like React and Angular have become popular choices for building client-side rendered applications.

One of the key benefits of CSR is that it enables websites to be more interactive and dynamic. With CSR, it's possible to build highly interactive applications that allow users to perform complex tasks, such as booking a flight or making a purchase, without having to wait for the page to reload after each action.

However, CSR has its own set of challenges. One of the biggest issues is search engine optimization (SEO), as search engines struggle to crawl and index content that is generated on the client side. This can impact a website's search rankings and visibility.

Another challenge with CSR is that it can be more difficult to ensure that websites work well on a wide range of devices. This is because the client device needs to have a powerful processor and fast internet connection to render the page quickly. If the device is slow or has a poor internet connection, the page may load slowly or not at all, leading to a poor user experience.
### Pros of CSR
- Interactive user experience: CSR allows for dynamic and interactive user interfaces, as it allows the client to handle most of the rendering.
- Efficient use of server resources: Since the server only sends data, rather than generating entire HTML pages, CSR is more resource-efficient on the server side.
- Good for complex, dynamic websites: CSR is an ideal approach for websites that require frequent updates or complex user interactions.
### Cons of CSR
- Poor SEO: Since search engines have difficulty crawling and indexing content that is generated on the client side, CSR can negatively impact a website's search rankings and visibility.
- Slow initial page load times: Since the client needs to do most of the rendering, the initial page load time can be slower compared to SSR.
- Device compatibility issues: CSR can be challenging to implement for devices with slow processors or limited internet connectivity, leading to a poor user experience.
### Examples of CSR
- Gmail: Gmail is an example of a web application that uses CSR to provide an interactive user experience.
- Facebook: Facebook uses CSR to render content dynamically and provide a seamless user experience.
## **The Present and Future: Hybrid Rendering**
To address the SEO challenges of CSR, developers have started to use hybrid rendering techniques. Hybrid rendering combines the best of both worlds, allowing developers to use SSR for the initial page load and then switch to CSR for subsequent updates. Frameworks like Next.js and Nuxt.js have become popular choices for hybrid rendering applications.

One of the key benefits of hybrid rendering is that it enables websites to be both highly interactive and optimized for search engines. By using SSR for the initial page load, search engines can crawl and index the content more easily, leading to better search rankings and visibility. Then, by switching to CSR for subsequent updates, the website can provide a highly interactive and dynamic user experience.

Another benefit of hybrid rendering is that it can help to ensure that websites work well on a wide range of devices. By using SSR for the initial page load, the website can load quickly even on devices with slow processors or poor internet connections. Then, by switching to CSR for subsequent updates, the website can provide a highly interactive and dynamic user experience on devices with powerful processors and fast internet
### Pros of Hybrid Rendering
- Optimized for search engines: By using SSR for the initial page load, search engines can crawl and index the content more easily, leading to better search rankings and visibility.
- Interactive user experience: By switching to CSR for subsequent updates, the website can provide a highly interactive and dynamic user experience.
- Device compatibility: By using SSR for the initial page load, the website can load quickly even on devices with slow processors or poor internet connections, and then switch to CSR for subsequent updates on devices with powerful processors and fast internet connections.
### Cons of Hybrid Rendering
- Complexity: Hybrid rendering can be more complex to implement than either SSR or CSR, as it requires developers to use multiple rendering approaches.
- Performance: Hybrid rendering can have slower initial page load times than pure CSR, as it requires both SSR and CSR.
- Development time: Hybrid rendering can require more development time compared to pure SSR or CSR, as it requires developers to switch between multiple rendering approaches.
### Examples of Hybrid Rendering
- Airbnb: Airbnb uses Next.js, a hybrid rendering framework, to optimize search engine rankings while still providing an interactive user experience.
- Hulu: Hulu uses Nuxt.js, another hybrid rendering framework, to provide a highly interactive and dynamic user experience while optimizing search engine visibility.


## **Conclusion**
Content rendering is a crucial factor in website development, and choosing the right approach can make or break a website's success. Server-side rendering was the primary approach in the early days of the internet and still has its advantages, such as fast initial page load times and good SEO. However, client-side rendering has become increasingly popular due to its dynamic and interactive user experience. While it can pose challenges in terms of SEO and device compatibility, hybrid rendering techniques have emerged as a solution to these issues. By combining the benefits of both server-side and client-side rendering, hybrid rendering provides an optimized user experience while maintaining good search engine visibility.

As website development continues to evolve, it's essential to stay up-to-date with the latest rendering approaches and choose the one that best suits your website's needs. Each approach has its pros and cons, and the decision ultimately depends on the website's complexity, content, and business requirements. Whether it's server-side rendering, client-side rendering, or hybrid rendering, the key is to strike the right balance between performance, interactivity, and search engine optimization. With the right approach, developers can build websites that are fast, engaging, and easy to find

Let us to know what problem solved by react and what react and why it is 

We start in next page



**What Is React?**

**React is an open–source JavaScript library commonly used on the front–end side of web development, specifically for building user interfaces and reusable UI components. It was developed by Facebook for their own use in 2011 and was open–sourced two years later. After that, React took the tech world by storm, endearing developers with an easier learning curve (unlike Angular, for example), lightning–fast development, and thriving community of React developers, ready to help out in a tight spot anytime. The rise of React Development Services is also a big bonus.**.
## **Is React Native The Same Thing?**
React is a library used in web development, while **[React Native](https://massivepixel.io/blog/react-vs-react-native/) is one of the JavaScript frameworks, used for building cross-platform mobile apps.** Not sure where the difference lies between a library and a framework?

**A library is a collection of objects, helper functions, and methods,** meant for performing specific operations. Since all the components are reusable, you don’t have to rewrite the code every single time, following the rule of [keeping your code DRY](https://www.drycode.io/) (Don’t Repeat Yourself).

**Framework**, on the other hand, is a **collection of many libraries, APIs, predefined functions, and objects.** It gives you a base functionality that you can build upon to create more complex applications, significantly shortening the development process. Additionally, frameworks come with their own default behavior, dictating how the application should be designed, while libraries offer more fl Is React Native The Same Thing?

React is a library used in web development, while React Native is one of the JavaScript frameworks, used for building cross-platform mobile apps. Not sure where the difference lies between a library and a framework?

A library is a collection of objects, helper functions, and methods, meant for performing specific operations. Since all the components are reusable, you don’t have to rewrite the code every single time, following the rule of keeping your code DRY (Don’t Repeat Yourself).

Framework, on the other hand, is a collection of many libraries, APIs, predefined functions, and objects. It gives you a base functionality that you can build upon to create more complex applications, significantly shortening the development process. Additionally, frameworks come with their own default behavior, dictating how the application should be designed, while libraries offer more flexibility.

React and React Native share some things in common, but they’re still different technologies. For example, they share the same special syntax and principles, which makes it easy to learn React while knowing its mobile counterpart. But the rendering happens differently; React uses VirtualDOM, while React Native needs a native API for that.

Combining the two though — creating web applications of the highest quality, followed by mobile applications of the same standard — is a sure way to win over end-users by making your products wholly accessible.

React’s Strengths And Benefits

1\. Interactive User Interfaces Made Simple

While we want to promote the “don’t judge the book by its cover” approach, it is undeniable that the look and feel of web applications influence the direct engagement of end-users. If the product isn’t user–friendly and goes against typical user behavior, it’s a bust.

With React, the process of creating pleasing and functional user interfaces is way easier compared to other JavaScript libraries. It’s possible due to declarative components, which are used to describe the desired outcome instead of direct steps to achieve just that. Those exact steps are left to the program to figure out, which saves a tremendous amount of time.

You’re also saving time in the future since maintenance and debugging are effortless as well.

2\. High–Performance With Virtual DOM

Speed matters more than ever. 

The users no longer have the patience to wait for the site to load nor will they forgive any web apps for responding too slowly to their actions. Any product that’s made with profit in mind, needs to be at its best efficiency.

Back in the day, server-side rendering was a standard, but one that fell short of the needs of single-page applications. Rendering the components every time the user interacted with the page made it a rather bothersome experience.

That’s what Facebook thought as well. Hence, the creation of React.

React’s main strength lies in Virtual DOM, a virtual representation of the Document Object Layout that keeps all the changes implemented in the UI in its memory until it finds the least expensive way to update and render the real DOM. This render method, called reconciliation, lowers the overall number of necessary updates, leading to better, the faster performance of even the most complex applications.exibility.

React and React Native share some things in common, but **they’re still different technologies.** For example, they share the same special syntax and principles, which makes it easy to learn React while knowing its mobile counterpart. But the rendering happens differently; React uses VirtualDOM, while React Native needs a native API for that.

Combining the two though — creating web applications of the highest quality, followed by mobile applications of the same standard** — is a sure way to win over end-users by making your products wholly accessible.
## **React’s Strengths And Benefits**
### 1\. Interactive User Interfaces Made Simple
While we want to promote the “don’t judge the book by its cover” approach, it is undeniable that the look and feel of web applications influence the direct engagement of end-users. If the product isn’t user–friendly and goes against typical user behavior, it’s a bust.

With React, **the process of creating pleasing and functional user interfaces is way easier** compared to other JavaScript libraries. It’s possible due to **declarative components,** which are used to describe the desired outcome instead of direct steps to achieve just that. Those exact steps are left to the program to figure out, which saves a tremendous amount of time.

You’re also **saving time in the future** since maintenance and debugging are effortless as well.
### 2\. High–Performance With Virtual DOM
**Speed matters more than ever.** 

The users no longer have the patience to wait for the site to load nor will they forgive any web apps for responding too slowly to their actions. A Is React Native The Same Thing?

React is a library used in web development, while React Native is one of the JavaScript frameworks, used for building cross-platform mobile apps. Not sure where the difference lies between a library and a framework?

A library is a collection of objects, helper functions, and methods, meant for performing specific operations. Since all the components are reusable, you don’t have to rewrite the code every single time, following the rule of keeping your code DRY (Don’t Repeat Yourself).

Framework, on the other hand, is a collection of many libraries, APIs, predefined functions, and objects. It gives you a base functionality that you can build upon to create more complex applications, significantly shortening the development process. Additionally, frameworks come with their own default behavior, dictating how the application should be designed, while libraries offer more flexibility.

React and React Native share some things in common, but they’re still different technologies. For example, they share the same special syntax and principles, which makes it easy to learn React while knowing its mobile counterpart. But the rendering happens differently; React uses VirtualDOM, while React Native needs a native API for that.

Combining the two though — creating web applications of the highest quality, followed by mobile applications of the same standard — is a sure way to win over end-users by making your products wholly accessible.

React’s Strengths And Benefits

1\. Interactive User Interfaces Made Simple

While we want to promote the “don’t judge the book by its cover” approach, it is undeniable that the look and feel of web applications influence the direct engagement of end-users. If the product isn’t user–friendly and goes against typical user behavior, it’s a bust.

With React, the process of creating pleasing and functional user interfaces is way easier compared to other JavaScript libraries. It’s possible due to declarative components, which are used to describe the desired outcome instead of direct steps to achieve just that. Those exact steps are left to the program to figure out, which saves a tremendous amount of time.

You’re also saving time in the future since maintenance and debugging are effortless as well.

2\. High–Performance With Virtual DOM

Speed matters more than ever. 

The users no longer have the patience to wait for the site to load nor will they forgive any web apps for responding too slowly to their actions. Any product that’s made with profit in mind, needs to be at its best efficiency.

Back in the day, server-side rendering was a standard, but one that fell short of the needs of single-page applications. Rendering the components every time the user interacted with the page made it a rather bothersome experience.

That’s what Facebook thought as well. Hence, the creation of React.

React’s main strength lies in Virtual DOM, a virtual representation of the Document Object Layout that keeps all the changes implemented in the UI in its memory until it finds the least expensive way to update and render the real DOM. This render method, called reconciliation, lowers the overall number of necessary updates, leading to better, the faster performance of even the most complex applications.ny product that’s made with profit in mind, needs to be at its best efficiency.

Back in the day, **server-side** rendering was a standard, but one that fell short of the needs of single-page applications. Rendering the components every time the user interacted with the page made it a rather bothersome experience.

That’s what Facebook thought as well. Hence, the creation of React.

**React’s main strength lies in Virtual DOM,** a virtual representation of the **Document Object Layout** that keeps all the changes implemented in the UI in its memory until it finds the least expensive way to update and render the real DOM. This render method, called [reconciliation](https://reactjs.org/blog/2013/06/05/why-react.html), lowers the overall number of necessary updates, leading to better, the faster performance of even the most complex applications.

### 3\. Reusable Components For Lightning–Fast Development
React makes building web applications a breeze and the reason why lies with **component reusability.** All the components have their own logic and are independent of each other, which makes them easy to reuse several times across applications. **Write once, and use everywhere** — that’s how React’s often described.

Also in React, components are not the only reusable thing. You can also [reuse stateful logic](https://buttercms.com/blog/learn-react-hooks-by-writing-your-first-hook) without changing the component hierarchy. This feature was introduced as **React Hooks** along with [React 16.8 in 2019](https://reactjs.org/blog/2019/02/06/react-v16.8.0.html). Its purpose lies in making components less complex, the code more manageable, and the bugs easier to hunt down.

Before the introduction of React Hooks, [Higher-Order Components](https://reactjs.org/docs/higher-order-components.html) were used for composing behavior. As a pattern that stems from React’s compositional nature, its purpose is to take a component as an argument and return a new component. Sounds familiar? HOCs were [inspired by higher-order functions in JavaScript](https://www.smashingmagazine.com/2020/06/higher-order-components-react/).

Whether it’s better to use React Hooks or Higher-Order Components [depends entirely on circumstances](https://medium.com/javascript-scene/do-react-hooks-replace-higher-order-components-hocs-7ae4a08b7b58). For example, if the behavior is restricted to a single component, React Hooks are a better choice, while Higher-Order Components do well when there are no bunch of props involved.

With this level of reusability, you benefit from faster development, efficient scalability, and easy maintenance that can save both money and time.
### 4\. Clean Abstraction Layer In The Name Of Simplicity
Abstraction is **responsible for reducing informational load and hiding complex internals** from the end-user. It’s a thing of necessity that requires a depth of knowledge of design architecture, like MVP (Model–View–Presenter), MVC (Model–View–Controller), or **MVVM** (Model–View–View–Model). They are commonly used in frameworks to divide the application into different logic components.

But React is not a framework and therefore, it doesn’t abide by architectural pattern’s rules — which translates into **more flexibility in terms of building the product.** And developers only need to know the fundamentals to proceed, which makes using React such a delight.
### 5\. One–Way Data Flow Means Stable Code
React answered the challenge of managing the interplay between data and application state in the form of [unidirectional data flow](https://www.exclamationlabs.com/blog/the-case-for-unidirectional-data-flow/). The alternative, the bidirectional data flow, blocks the view layer from recognizing where the data is coming from, just like the model doesn’t know how that data is presented. And while a simple web application can work well with that, the more complex ones could find themselves in a tight spot — the constant flow of data is hard to manage, control, and maintain, while all the errors are more difficult to pinpoint.

**One–way data binding solves this problem by ensuring a predictable application state.**

With the downward motion comes **code stability:** any changes done to child elements won’t affect parent data, which is great news for software developers focusing on building projects with future expansion in mind.
### 6\. Many Useful Developer Tools To Choose From
Developer tools come in handy every single time you need to increase efficiency, save time, or simply make your job easier. And the more popular the technology, the more to choose from — and so with React, **nobody can complain about the scarcity of tools.**

You can use [Why did you render](https://github.com/welldone-software/why-did-you-render) for debugging the behavior of any React component, [Bit](https://bit.dev/) for creating and sharing your composable components for improved teamwork, or [Storybook](https://storybook.js.org/) if you ever need to do some solid UI testing. And that’s just the tip of the iceberg.

Above them all, two developer tools stand out exceptionally well: **React Developer Tools** and **Redux Developer Tools.**

**React Developer Tools** gives you **insight into a React tree** and lets you inspect the app’s architecture and all its components, from hooks and states to props. You can also use it for running experiments via the Profiler tab by testing interactions in the web application. So if you want to understand how React components affect each other, this extension, available both on Chrome and Firefox, is a must-have.

**Redux Developer Tools**, on the other hand, is useful for those who along with React use **Redux**, a [state container](https://redux.js.org/) used for **state management**. Redux Developer Tools is **helpful in keeping track of each state and dispatched action,** lets you go back to any recorded state for easier debugging, and keeps the apps’ behavior consistent across many platforms. What’s not to love?
### 7\. Support On Many Fronts
React is not only wholeheartedly supported by its creator, Facebook — which it must since its livelihood depends on it — but also by a giant community of developers from all around the world. This results in a staggering number of tutorials, resources, tips, and guides, many of which are free and open-sourced. They can be found on sites such as [Stack Overflow](https://stackoverflow.com/), [Reddit](https://www.reddit.com/r/reactjs/), [Dev.to](https://dev.to/t/react), and [on many other blogs, podcasts and Youtube channels](https://massivepixel.io/blog/web-development-blogs/). And for those in a real hurry — there are even [component libraries](https://retool.com/blog/react-component-libraries/) available for free.
### 8\. Hand In Hand With Search Engine Optimization
In the end, even the most beautiful web application** won’t do its job if it’s hidden away in the depths of the internet and therefore, is far beyond consumers’ awareness. That’s why it’s crucial to play along with Google and put some effort into growing your site’s ranking. This also depends on the type of content you share such as infographics, [online podcasts](https://podcastle.ai/blog/audio-chat-online-podcast-or-radio/), etc. So, together, these approaches will help improve site performance.

And since with React it’s easy to develop **lightweight, fully responsive websites with a meaningful structure,** it’s a perfect technology to use from a business standpoint.
## **Key Takeaways: 8 Reasons Why React Is So Popular**
Using React JS, a JavaScript library used and developed by Facebook, is a smart choice for those who appreciate rapid development, quick results, stress–free maintenance. Let’s sum up all the benefits that come from using React in web development:

1. **High user engagement** due to interactive, responsive interfaces** that make the user experience a real pleasure,
1. Virtual DOM ensures high–performance that holds up even in the most complex of projects,
1. Lightning–Fast Development significantly reduces time–to–market, all thanks to reusable React components,
1. The clean abstraction layer additionally **facilitates the development process** and **lowers the entry threshold**,
1. One–way data flow guarantees **stable code** and **easier debugging**,
1. Many useful developer tools make the whole **development process more efficient**,
1. React is **supported by its creator**, Facebook, as well as by an active community, thanks to which **many tutorials, guides, and tips** are offered,
1. With React, **building SEO–friendly projects is effortless.**

Let us go to the benefit of using framework we all it is easier to use it but we will know  more of that 
### `  `What is a Web Framework?
A software framework is an abstract concrete/conceptual platform where developers can selectively modify a planned override with standard codes for standard functions. However, the framework comes with a predefined code base that can be used to alter campaign spaces.
Websites frameworks typically support one or more coding programs that accelerate development with minimal coding suites. Today's popular images on the internet are Angular, Express.js, Flask, Django, jQuery, PHP, Laravel, and Ruby on Rails.
However, the languages commonly used for online programming programs include Java, JavaScript, Python, PHP, Perl, and Ruby.
### Benefits of Using Web Development Frameworks
Unlike many other development tools, a framework provides a pre-configured code base and guidelines to facilitate web development. At the same time, it accelerates the development of software and plugins like [**WooCommerce stock manager**](https://codecanyon.net/item/woocommerce-product-stock-manager/21703841?s_rank=3) that helps increase eCommerce conversion and shortens the time spent on the market, reducing the life cycle of the development system.
Below are the key benefits of using frameworks to develop online programs.

**1. Makes easier the Development Process**
The frameworks provide the tools and packages to help people start developing their websites.
Thanks to the frameworks, the software does not have to write all the scripts from scratch, as the framework handles many standard templates developed from scratch. They also offer beginners opportunities to explore important areas and offer people a wide range of tools and experts.
Frames significantly reduce coding time because they launch the basic structure and store network programs in the form of a ship.

**2. Eases Debugging and Application Maintenance**
Many programming languages do not place much emphasis on the readability and robustness of code during flight.
Frames do that; although developing a framework-adapted online program is highly recommended, it has a lot to do with ease of debugging and maintenance.
Because there is a community of developments associated with each framework, there is always an immediate response to any problems that arise with the foundation. In addition, many models allow developers to run their first tests.

**3. Reduces Code Length**
There is no need to write long lines of rules with frames but add common patterns on the website.
Therefore introduce quickly and clearly in the code section. This reduction in additional time and effort is often associated with overall performance development.
In addition, the frameworks provide features and tools that allow developers to go about automating everyday tasks such as Internet development, text storage, session management authentication, and URL mapping.

**4. Improves Database Proficiency**
Many frameworks start with a set of rules that allow programs to work with related data repeatedly.
Although some standards facilitate data integration, they include an under-radar Object Relational Mapping (ORM) engine. Other examples use this ORM object to write directly to programming languages.
Moreover, developers can use this ORM model to perform database functions without writing long SQL codes.

**5. Reinforces security**
Developers do not need snapshots to protect the security of their online programs, such as SQL injection, web application fraud, and database manipulation.
The built-in security features and methods provide developers with a more common way to protect a website from current and future security threats.
Developers can also use features and tools as their basic capabilities to rely on special protection for their websites.
### Frameworks vs. Libraries
Frameworks are a kind of programming abstraction that connects the author of the rules. A core program is a complete reusable software environment that provides unique features as part of standard software. This facilitates the development of programs, products, and solutions.
Software frameworks can include software applications, integrations, library numbers, tools, and programming interfaces (APIs) that integrate different components to develop a project or program. Frames are very similar to libraries and are popular these days, but they have a look that sets them apart from traditional libraries.

- Inversion of control: Within the system, the overall flow of the regulatory program is monitored by the fund and not by telephone. This is the opposite of how libraries are used when the caller controls the flow of instructions.
- Extensibility: the user can expand the framework- usually in the illegal chain; or programs that can add cultural norms to provide unique functions.
- Non-modifiable framework code: the rule-based system does not need to be upgraded, but upgrades can be accepted. In other words, users can expand the foundation without having to change its rules.

The structure itself provides reliable control of the flow rate. What you need to do is give the executives a well-understood business book, and the framework will call them, clearing your mind about aggregated data, transactions, model travel data, and more. Then, clearly define classes, transfer format, allocate resources, etc.
It is not a waste of time to perform something important. For example, the modeling test units should have no open spaces that allow developers to put in their tests, and the framework will see them see the rest.
The basic test unit is just a straightforward example of a foundation. However, the skeleton is usually cared for much better. Take the power of the Source, for example. It has a wide range of tools for creating and managing large-scale transactions, security, blockchain operations, and more.
The list goes on and on. Finally, a framework can run a project - developers often need to file files (for example, a database) and begin implementing business law correctly.

**Libraries**
In real life, libraries are places where you can get free information. But from a programming standpoint, a library is a set of materials, operations, and methods (depending on the language) that can be reused and shared among many applications. It is a professionally created library with well-defined procedures.
A library is often built when there is a problem with a specific area familiar with programs. For example, typical examples of functions and data structures are not built into the language, such as add-on extensions, collection extensions, etc.
The library must provide the API that your number calls. This means that your number governs the use of library features. This is an essential difference between a collection and a library. If you use a library, your number calls the library; the frame dials your number when using the base.

Let we us know about the principles of react 
# Design Principles
###

### Composition
The key feature of React is composition of components. Components written by different people should work well together. It is important to us that you can add functionality to a component without causing rippling changes throughout the codebase.

For example, it should be possible to introduce some local state into a component without changing any of the components using it. Similarly, it should be possible to add some initialization and teardown code to any component when necessary.

There is nothing “bad” about using state or lifecycle methods in components. Like any powerful feature, they should be used in moderation, but we have no intention to remove them. On the contrary, we think they are integral parts of what makes React useful. We might enable [more functional patterns](https://github.com/reactjs/react-future/tree/master/07%20-%20Returning%20State) in the future, but both local state and lifecycle methods will be a part of that model.

Components are often described as “just functions” but in our view they need to be more than that to be useful. In React, components describe any composable behavior, and this includes rendering, lifecycle, and state. Some external libraries like [Relay](https://facebook.github.io/relay/) augment components with other responsibilities such as describing data dependencies. It is possible that those ideas might make it back into React too in some form.
### Common Abstraction
In general we [resist adding features](https://www.youtube.com/watch?v=4anAwXYqLG8) that can be implemented in userland. We don’t want to bloat your apps with useless library code. However, there are exceptions to this.

For example, if React didn’t provide support for local state or lifecycle methods, people would create custom abstractions for them. When there are multiple abstractions competing, React can’t enforce or take advantage of the properties of either of them. It has to work with the lowest common denominator.

This is why sometimes we add features to React itself. If we notice that many components implement a certain feature in incompatible or inefficient ways, we might prefer to bake it into React. We don’t do it lightly. When we do it, it’s because we are confident that raising the abstraction level benefits the whole ecosystem. State, lifecycle methods, cross-browser event normalization are good examples of this.

We always discuss such improvement proposals with the community. You can find some of those discussions by the [“big picture”](https://github.com/facebook/react/issues?q=is:open+is:issue+label:%22Type:+Big+Picture%22) label on the React issue tracker.
### Escape Hatches
React is pragmatic. It is driven by the needs of the products written at Facebook. While it is influenced by some paradigms that are not yet fully mainstream such as functional programming, staying accessible to a wide range of developers with different skills and experience levels is an explicit goal of the project.

If we want to deprecate a pattern that we don’t like, it is our responsibility to consider all existing use cases for it and [educate the community about the alternatives](https://legacy.reactjs.org/blog/2016/07/13/mixins-considered-harmful.html) before we deprecate it. If some pattern that is useful for building apps is hard to express in a declarative way, we will [provide an imperative API](https://legacy.reactjs.org/docs/more-about-refs.html) for it. If we can’t figure out a perfect API for something that we found necessary in many apps, we will [provide a temporary subpar working API](https://legacy.reactjs.org/docs/legacy-context.html) as long as it is possible to get rid of it later and it leaves the door open for future improvements.
### Stability
We value API stability. At Facebook, we have more than 50 thousand components using React. Many other companies, including [Twitter](https://twitter.com/) and [Airbnb](https://www.airbnb.com/), are also heavy users of React. This is why we are usually reluctant to change public APIs or behavior.

However we think stability in the sense of “nothing changes” is overrated. It quickly turns into stagnation. Instead, we prefer the stability in the sense of “It is heavily used in production, and when something changes, there is a clear (and preferably automated) migration path.”

When we deprecate a pattern, we study its internal usage at Facebook and add deprecation warnings. They let us assess the impact of the change. Sometimes we back out if we see that it is too early, and we need to think more strategically about getting the codebases to the point where they are ready for this change.

If we are confident that the change is not too disruptive and the migration strategy is viable for all use cases, we release the deprecation warning to the open source community. We are closely in touch with many users of React outside of Facebook, and we monitor popular open source projects and guide them in fixing those deprecations.

Given the sheer size of the Facebook React codebase, successful internal migration is often a good indicator that other companies won’t have problems either. Nevertheless sometimes people point out additional use cases we haven’t thought of, and we add escape hatches for them or rethink our approach.

We don’t deprecate anything without a good reason. We recognize that sometimes deprecations warnings cause frustration but we add them because deprecations clean up the road for the improvements and new features that we and many people in the community consider valuable.

For example, we added a [warning about unknown DOM props](https://legacy.reactjs.org/warnings/unknown-prop.html) in React 15.2.0. Many projects were affected by this. However fixing this warning is important so that we can introduce the support for [custom attributes](https://github.com/facebook/react/issues/140) to React. There is a reason like this behind every deprecation that we add.

When we add a deprecation warning, we keep it for the rest of the current major version, and [change the behavior in the next major version](https://legacy.reactjs.org/blog/2016/02/19/new-versioning-scheme.html). If there is a lot of repetitive manual work involved, we release a [codemod](https://www.youtube.com/watch?v=d0pOgY8__JM) script that automates most of the change. Codemods enable us to move forward without stagnation in a massive codebase, and we encourage you to use them as well.

You can find the codemods that we released in the [react-codemod](https://github.com/reactjs/react-codemod) repository.
### Interoperability
We place high value in interoperability with existing systems and gradual adoption. Facebook has a massive non-React codebase. Its website uses a mix of a server-side component system called XHP, internal UI libraries that came before React, and React itself. It is important to us that any product team can [start using React for a small feature](https://www.youtube.com/watch?v=BF58ZJ1ZQxY) rather than rewrite their code to bet on it.

This is why React provides escape hatches to work with mutable models, and tries to work well together with other UI libraries. You can wrap an existing imperative UI into a declarative component, and vice versa. This is crucial for gradual adoption.
### Scheduling
Even when your components are described as functions, when you use React you don’t call them directly. Every component returns a [description of what needs to be rendered](https://legacy.reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html#elements-describe-the-tree), and that description may include both user-written components like <LikeButton> and platform-specific components like <div>. It is up to React to “unroll” <LikeButton> at some point in the future and actually apply changes to the UI tree according to the render results of the components recursively.

This is a subtle distinction but a powerful one. Since you don’t call that component function but let React call it, it means React has the power to delay calling it if necessary. In its current implementation React walks the tree recursively and calls render functions of the whole updated tree during a single tick. However in the future it might start [delaying some updates to avoid dropping frames](https://github.com/facebook/react/issues/6170).

This is a common theme in React design. Some popular libraries implement the “push” approach where computations are performed when the new data is available. React, however, sticks to the “pull” approach where computations can be delayed until necessary.

React is not a generic data processing library. It is a library for building user interfaces. We think that it is uniquely positioned in an app to know which computations are relevant right now and which are not.

If something is offscreen, we can delay any logic related to it. If data is arriving faster than the frame rate, we can coalesce and batch updates. We can prioritize work coming from user interactions (such as an animation caused by a button click) over less important background work (such as rendering new content just loaded from the network) to avoid dropping frames.

To be clear, we are not taking advantage of this right now. However the freedom to do something like this is why we prefer to have control over scheduling, and why setState() is asynchronous. Conceptually, we think of it as “scheduling an update”.

The control over scheduling would be harder for us to gain if we let the user directly compose views with a “push” based paradigm common in some variations of [Functional Reactive Programming](https://en.wikipedia.org/wiki/Functional_reactive_programming). We want to own the “glue” code.

It is a key goal for React that the amount of the user code that executes before yielding back into React is minimal. This ensures that React retains the capability to schedule and split work in chunks according to what it knows about the UI.

There is an internal joke in the team that React should have been called “Schedule” because React does not want to be fully “reactive”.
### Developer Experience
Providing a good developer experience is important to us.

For example, we maintain [React DevTools](https://github.com/facebook/react/tree/main/packages/react-devtools) which let you inspect the React component tree in Chrome and Firefox. We have heard that it brings a big productivity boost both to the Facebook engineers and to the community.

We also try to go an extra mile to provide helpful developer warnings. For example, React warns you in development if you nest tags in a way that the browser doesn’t understand, or if you make a common typo in the API. Developer warnings and the related checks are the main reason why the development version of React is slower than the production version.

The usage patterns that we see internally at Facebook help us understand what the common mistakes are, and how to prevent them early. When we add new features, we try to anticipate the common mistakes and warn about them.

We are always looking out for ways to improve the developer experience. We love to hear your suggestions and accept your contributions to make it even better.
### Debugging
When something goes wrong, it is important that you have breadcrumbs to trace the mistake to its source in the codebase. In React, props and state are those breadcrumbs.

If you see something wrong on the screen, you can open React DevTools, find the component responsible for rendering, and then see if the props and state are correct. If they are, you know that the problem is in the component’s render() function, or some function that is called by render(). The problem is isolated.

If the state is wrong, you know that the problem is caused by one of the setState() calls in this file. This, too, is relatively simple to locate and fix because usually there are only a few setState() calls in a single file.

If the props are wrong, you can traverse the tree up in the inspector, looking for the component that first “poisoned the well” by passing bad props down.

This ability to trace any UI to the data that produced it in the form of current props and state is very important to React. It is an explicit design goal that state is not “trapped” in closures and combinators, and is available to React directly.

While the UI is dynamic, we believe that synchronous render() functions of props and state turn debugging from guesswork into a boring but finite procedure. We would like to preserve this constraint in React even though it makes some use cases, like complex animations, harder.
### Configuration
We find global runtime configuration options to be problematic.

For example, it is occasionally requested that we implement a function like React.configure(options) or React.register(component). However this poses multiple problems, and we are not aware of good solutions to them.

What if somebody calls such a function from a third-party component library? What if one React app embeds another React app, and their desired configurations are incompatible? How can a third-party component specify that it requires a particular configuration? We think that global configuration doesn’t work well with composition. Since composition is central to React, we don’t provide global configuration in code.

We do, however, provide some global configuration on the build level. For example, we provide separate development and production builds. We may also [add a profiling build](https://github.com/facebook/react/issues/6627) in the future, and we are open to considering other build flags.
### Beyond the DOM
We see the value of React in the way it allows us to write components that have fewer bugs and compose together well. DOM is the original rendering target for React but [React Native](https://reactnative.dev/) is just as important both to Facebook and the community.

Being renderer-agnostic is an important design constraint of React. It adds some overhead in the internal representations. On the other hand, any improvements to the core translate across platforms.

Having a single programming model lets us form engineering teams around products instead of platforms. So far the tradeoff has been worth it for us.
### Implementation
We try to provide elegant APIs where possible. We are much less concerned with the implementation being elegant. The real world is far from perfect, and to a reasonable extent we prefer to put the ugly code into the library if it means the user does not have to write it. When we evaluate new code, we are looking for an implementation that is correct, performant and affords a good developer experience. Elegance is secondary.

We prefer boring code to clever code. Code is disposable and often changes. So it is important that it [doesn’t introduce new internal abstractions unless absolutely necessary](https://youtu.be/4anAwXYqLG8?t=13m9s). Verbose code that is easy to move around, change and remove is preferred to elegant code that is prematurely abstracted and hard to change.
### Optimized for Tooling
Some commonly used APIs have verbose names. For example, we use componentDidMount() instead of didMount() or onMount(). This is [intentional](https://github.com/reactjs/react-future/issues/40#issuecomment-142442124). The goal is to make the points of interaction with the library highly visible.

In a massive codebase like Facebook, being able to search for uses of specific APIs is very important. We value distinct verbose names, and especially for the features that should be used sparingly. For example, dangerouslySetInnerHTML is hard to miss in a code review.

Optimizing for search is also important because of our reliance on [codemods](https://www.youtube.com/watch?v=d0pOgY8__JM) to make breaking changes. We want it to be easy and safe to apply vast automated changes across the codebase, and unique verbose names help us achieve this. Similarly, distinctive names make it easy to write custom [lint rules](https://github.com/yannickcr/eslint-plugin-react) about using React without worrying about potential false positives.

[JSX](https://legacy.reactjs.org/docs/introducing-jsx.html) plays a similar role. While it is not required with React, we use it extensively at Facebook both for aesthetic and pragmatic reasons.

In our codebase, JSX provides an unambiguous hint to the tools that they are dealing with a React element tree. This makes it possible to add build-time optimizations such as [hoisting constant elements](https://babeljs.io/docs/en/babel-plugin-transform-react-constant-elements/), safely lint and codemod internal component usage, and [include JSX source location](https://github.com/facebook/react/pull/6771) into the warnings.
### Dogfooding
We try our best to address the problems raised by the community. However we are likely to prioritize the issues that people are *also* experiencing internally at Facebook. Perhaps counter-intuitively, we think this is the main reason why the community can bet on React.

Heavy internal usage gives us the confidence that React won’t disappear tomorrow. React was created at Facebook to solve its problems. It brings tangible business value to the company and is used in many of its products. [Dogfooding](https://en.wikipedia.org/wiki/Eating_your_own_dog_food) it means that our vision stays sharp and we have a focused direction going forward.

This doesn’t mean that we ignore the issues raised by the community. For example, we added support for [web components](https://legacy.reactjs.org/docs/webcomponents.html) and [SVG](https://github.com/facebook/react/pull/6243) to React even though we don’t rely on either of them internally. We are actively [listening to your pain points](https://github.com/facebook/react/issues/2686) and [address them](https://legacy.reactjs.org/blog/2016/07/11/introducing-reacts-error-code-system.html) to the best of our ability. The community is what makes React special to us, and we are honored to contribute back.

After releasing many open source projects at Facebook, we have learned that trying to make everyone happy at the same time produced projects with poor focus that didn’t grow well. Instead, we found that picking a small audience and focusing on making them happy brings a positive net effect. That’s exactly what we did with React, and so far solving the problems encountered by Facebook product teams has translated well to the open source community.

The downside of this approach is that sometimes we fail to give enough focus to the things that Facebook teams don’t have to deal with, such as the “getting started” experience. We are acutely aware of this, and we are thinking of how to improve in a way that would benefit everyone in the community without making the same mistakes we did with open source projects before

Now we will talk about mechanism of rendering in react 

**React rendering:**

React is fundamentally about rendering. Rendering is the process of transforming data into a visual representation on the screen. Rendering in React is performed by constructing components, which are reusable bits of code that may be combined to create new components.

When a component is rendered in React, a virtual representation of the user interface is created. This virtual representation, also known as the "virtual DOM, is a lightweight version of the actual DOM (Document Object Model) that React utilizes to track changes.

**Re-rendering in React:**

Data goes from parent components to child components in React via props. When the data changes, React immediately renders the affected components again. Rendering is the process of updating the virtual DOM with new data and calculating the fewest modifications required to update the actual DOM.

The redrawing technique in React is efficient because it only refreshes the elements of the UI that have changed rather than redrawing the entire thing. However, it can still be expensive. if not optimized properly, especially for large and complex applications.

**React Reconciliation:**

When rendering components, React employs a technique called reconciliation to maximize efficiency. The process of comparing the old virtual DOM tree to the new one and calculating the minimum number of changes required to update the actual DOM is known as reconciliation.

React compares the new virtual DOM tree to the old one when a component is rerendered and detects the sections of the tree that have changed. Instead of redrawing everything, it refreshes only those bits of the actual DOM.

The reconciliation process in React is efficient, but it can be difficult to optimize. Dealing with heavily nested components is one problem, as it might result in a massive virtual DOM tree that takes longer to reconcile.

**Factors impacting performance:**

Several factors impact performance when using React, including:

1\. Component tree structure: The structure of the component tree has a significant impact on performance. High-nested components can result in a huge virtual DOM tree, slowing reconciliation.

2\. State management: Proper state management is critical for optimizing the rendering and reconciliation of React. Poor state management might cause unnecessary redraws and slow down the program.

3\. Event processing: Event management in React can also have an impact on performance. Improper event handling might cause unnecessary redraws, slowing down the program.

4\. Data fetching: Asynchronous data fetching can also have an impact on performance. If data fetching is not streamlined, it can cause unnecessary renders and slow down the application.

**Tradeoffs and Challenges:**

There are tradeoffs and challenges to consider when maximizing performance in React. Improving performance by reducing the component tree, for example, may result in less flexibility and reusability. Optimizing state management may also necessitate more code, affecting readability and maintainability.

Another difficulty is balancing performance with user experience. While performance optimization is crucial, it should not come at the expense of the user experience. An application that is speedy but difficult to use will fail in the end.

In this post, we looked at the rendering process in React, including the terms rendering, rerendering, and reconciliation. We've also spoken about the important aspects that influence performance and the issues that come with optimizing performance with React.

Component organization, state management, event handling, and data fetching are all key elements to consider for optimizing React's rendering and reconciliation. However, it is equally critical to strike a balance between performance and user experience and to understand the tradeoffs inherent in various approaches.

Overall, React is an effective tool for creating user interfaces, but optimizing performance can be difficult. Developers may create quick and efficient applications that deliver a great user experience by understanding how React's rendering process works and addressing the important elements that affect performance

What is the DOM to know read the next 


DOM is a way to represent the webpage in a structured hierarchical way so that it will become easier for programmers and users to glide through the document. With DOM, we can easily access and manipulate tags, IDs, classes, Attributes, or Elements of HTML using commands or methods provided by the Document object. Using DOM, the JavaScript gets access to HTML as well as CSS of the web page and can also add behavior to the HTML elements. so basically **Document Object Model is an API that represents and interacts with HTML or XML documents.**

**Why DOM is required?**

HTML is used to **structure** the web pages and Javascript is used to add **behavior** to our web pages. When an HTML file is loaded into the browser, the javascript can not understand the HTML document directly. So, a corresponding document is created(DOM). **DOM is basically the representation of the same HTML document but in a different format with the use of objects**. Javascript interprets DOM easily i.e javascript can not understand the tags(<h1>H</h1>) in HTML document but can understand object h1 in DOM. Now, Javascript can access each of the objects (h1, p, etc) by using different functions.

**Structure of DOM**: DOM can be thought of as a Tree or Forest(more than one tree). The term **structure model** is sometimes used to describe the tree-like representation of a document.  Each branch of the tree ends in a node, and each node contains objects  Event listeners can be added to nodes and triggered on an occurrence of a given event. One important property of DOM structure models is ***structural isomorphism***: if any two DOM implementations are used to create a representation of the same document, they will create the same structure model, with precisely the same objects and relationships.

**Why called an Object Model?**
Documents are modeled using objects, and the model includes not only the structure of a document but also the behavior of a document and the objects of which it is composed like tag elements with attributes in HTML.

**Properties of DOM**: Let’s see the properties of the document object that can be accessed and modified by the document object.

Window Object: Window Object is object of the browser which is always at top of the hierarchy.  It is like an API that is used to set and access all the properties and methods of the browser. It is automatically created by the browser.

Document object: When an HTML document is loaded into a window, it becomes a document object. The ‘document’ object has various properties that refer to other objects which allow access to and modification of the content of the web page. If there is a need to access any element in an HTML page, we always start with accessing the ‘document’ object. Document object is property of window object.

Form Object: It is represented by form tags.

Link Object: It is represented by link tags.

Anchor Object: It is represented by a href tags.

Form Control Elements:: Form can have many control elements such as text fields, buttons, radio buttons, checkboxes, etc.

Methods of Document Object:

write(“string”): Writes the given string on the document.

getElementById(): returns the element having the given id value.

getElementsByName(): returns all the elements having the given name value.

getElementsByTagName(): returns all the elements having the given tag name.

getElementsByClassName(): returns all the elements having the given class name.

What is the virtual DOM amd pros and cons and Enhancement of the virtual DOM

Disadvantages of real DOM?

Every time DOM gets updated, the updated element and its children have to be rendered again to update the UI of our page. For this, each time there is a component update, the DOM needs to be updated and the UI components have to be re-rendered.
### What is Virtual DOM?
React uses Virtual DOM exists which is like a lightweight copy of the actual DOM(a virtual representation of the DOM). So for every object that exists in the original DOM, there is an object for that in React Virtual DOM. It is exactly the same, but it does not have the power to directly change the layout of the document. 

**Manipulating DOM is slow, but manipulating Virtual DOM is fast** as nothing gets drawn on the screen. So each time there is a change in the state of our application, the virtual DOM gets updated first instead of the real DOM. 
### How does virtual DOM actually make things faster?
When anything new is added to the application, a virtual DOM is created and it is represented as a tree. Each element in the application is a node in this tree. So, whenever there is a change in the state of any element, a new Virtual DOM tree is created. This new Virtual DOM tree is then compared with the previous Virtual DOM tree and make a note of the changes. After this, it finds the best possible ways to make these changes to the real DOM. Now only the updated elements will get rendered on the page again.
### How virtual DOM Helps React?
In React, everything is treated as a component be it a [functional component](https://www.geeksforgeeks.org/reactjs-functional-components/) or [class component.](https://www.geeksforgeeks.org/reactjs-class-based-components/) A component can contain a state. Whenever the state of any component is changed react updates its Virtual DOM tree. Though it may sound like it is ineffective the cost is not much significant as updating the virtual DOM doesn’t take much time. 

React maintains two Virtual DOM at each time, one contains the updated Virtual DOM and one which is just the pre-update version of this updated Virtual DOM. Now it compares the pre-update version with the updated Virtual DOM and figures out what exactly has changed in the DOM like which components have been changed. This process of comparing the current Virtual DOM tree with the previous one is known as[` `**‘diffing’**](https://www.geeksforgeeks.org/explain-dom-diffing/). Once React finds out what exactly has changed then it updates those objects only, on real DOM. 

React uses something called batch updates to update the real DOM. It just means that the changes to the real DOM are sent in batches instead of sending any update for a single change in the state of a component. 

We have seen that the re-rendering of the UI is the most expensive part and React manages to do this most efficiently by ensuring that the Real DOM receives batch updates to re-render the UI. This entire process of transforming changes to the real DOM is called [**Reconciliation](https://www.geeksforgeeks.org/reactjs-reconciliation/)**.**

This significantly improves the performance and is the main reason why React and its Virtual DOM are much loved by developers all around.

The diagrammatic image below briefly describes how the virtual DOM works in the real browser environment

**Differences between Virtual DOM and Real DOM**

|**Virtual DOM**|**Real DOM**|
| :-: | :-: |
|It is a lightweight copy of the original DOM|It is a tree representation of HTML elements|
|It is maintained by JavaScript libraries|It is maintained by the browser after parsing HTML elements|
|After manipulation it only re-renders changed elements|After manipulation, it re-render the entire DOM|
|Updates are lightweight|Updates are heavyweight|
|Performance is fast and UX is optimised|Performance is slow and the UX quality is low|
|Highly efficient as it performs batch updates|Less efficient due to re-rendering of DOM after each update|


### Some Pros and Cons Regarding Virtual DOM are Given Below:
The virtual DOM offers incredible performance. Beyond that, the virtual DOM has the following benefits:

- Increased performance and speed Lightweight
- It is easy to understand.
- The amazing diffing method that applies to more than only React
- Since everything that has a benefit also has a drawback, let's look at the negative aspects of virtual DOM:

Problems with higher memory use because the diffing algorithms must continually compare the pieces to determine which ones require updating or changing.

- It is difficult to incorporate into a lot of different frameworks.
- It cannot be utilized or targeted toward template engines.

Because of the improvement in performance and speed, it provides, virtual DOM is always preferred despite the drawbacks listed above.
## **How Virtual DOM Aids React?**
Every virtual DOM object is modified when a JSX element is rendered. This sounds very wasteful, but because the virtual DOM can update so quickly, the cost is negligible.

React compares the virtual DOM with a virtual DOM snapshot that was taken just before the update after the virtual DOM has been updated. React determines precisely which virtual DOM objects have changed by comparing the updated virtual DOM to a previous iteration. **"Diffing"** is the name of this procedure.

React updates just those objects on the real DOM after determining which virtual DOM objects have changed. In our previous example, React would be wise enough to rebuild the one item on your list that was checked off while leaving the rest of your list alone.

This does change things! React can only update the DOM's essential elements. This innovation is largely responsible for React's performance reputation.

Here is an overview of what takes place when you attempt to update the DOM with React:

- The virtual DOM is updated in its entirety.
- The virtual DOM is contrasted with how it appeared before your modification. Determined by React which objects have changed.
- The only objects that are updated on the real DOM are those that have been altered.
- The screen changes when the real DOM changes.
## **How is Virtual DOM Different from Shadow DOM?**
Before we conclude, let's address a frequently asked query. Does the virtual DOM correspond to the shadow DOM? Their behavior is distinct, to put it succinctly

The difference between jQuery and React
## **What is jQuery?**
jQuery is essentially a ‘lightweight’ JavaScript library. When it came out back in 2006, JavaScript was not as widely used, or even easy to use. But jQuery in a sense, revolutionized the industry, by wrapping many lines of JavaScript code into methods that you can call with a single line of code. The phrase ‘write less, do more’ can be exclusively used to define jQuery.

**Check out upGrad’s [Advanced Certification in DevOps**](https://www.upgrad.com/eg/devops-certification-pgc-iiitb/?utm_source=blog_details&utm_medium=BODY&utm_campaign=TV_SEDO_PGC_BLOG_BODY_93906)**

It also simplifies certain complex calls from JavaScript namely AJAX and DOM manipulation. So, it actually made it painless to shift from creating traditional websites to developing really dynamic web apps.

jQuery is till date the most popular and the most extendable JavaScript library. Many big companies like Google, Microsoft, and IBM use jQuery on the Web

jQuery Features

- jQuery supports HTML/DOM manipulation
- It also wraps HTML event methods
- It provides CSS manipulation
- It is easier to use effects and animations with jQuery
- AJAX calls are simplified on jQuery
- It is a library full of different utilities, including plugins for almost any kind of task out there
- jQuery runs exactly the same on almost all major browsers
## **What is React?**
React is an open source, declarative, efficient and extremely flexible JavaScript library that was created by Facebook in 2011, essentially for the purpose of building interactive UI elements. Before React developers used to build UIs by hand using raw JavaScript or using React predecessors like jQuery, which meant longer time and less accuracy. With React, all that changed. 

React provides reusable library code which cuts down on the total development time and also shortens the scope of errors. With React, developers can build large-scale, dynamic-looking single page applications that are sophisticated but convenient to use.

In addition to these, React has two key features that differentiates it from other libraries – JSX and Virtual DOM.

React Features

- Using React gives the developer access to React code snippets and components, thus they can create specific parts of an User Interface
- By using JSX you can directly manipulate DOM
- It also provides a Virtual DOM to improve the performance of the website
- It is an open source project
- There is a React library to attend to whatever specific UI function a developer needs to address
- The React library is growing exponentially, along with the community’s curated library add-ons

React for multi platforms

**React Native's popularity is still growing. Learn the pros and cons, and when to use React Native for your mobile app development.** 

React Native has gained widespread popularity across a range of industries, including world’s best-known apps like Facebook, Uber, and Pinterest built using it. What makes it so popular? Well, the ability to use **one codebase that runs on multiple platforms** is certainly one of the major factors in its success.

Before you decide to use React Native in one of your projects, read our guide so you can understand how it works and decide if it’s the **right fit for your specific needs.**
## **What is React Native?**
React Native is an open-source JavaScript framework, designed for building apps on multiple platforms like iOS, Android, and also web applications, **utilizing the very same code base**. It is based on React, and it brings all its glory to mobile app development.

Both frameworks: ReactJS (web) and React Native were brought to life by Facebook. React Native was a Hackathon project aiming at solving the company’s biggest pain point - maintaining two code bases for their app. The problem with maintaining two code bases for such a big app? Work duplication and, at times, solving the same problem in two different ways. React Native is a straightforward answer to these problems.

React Native uses JavaScript to compile the app’s user interface, but using native-OS views. For more complex features, it allows code implementation in OS-native languages (Swift and Objective-C for iOS, and Java and Kotlin for Android).
## **What is cross-platform development?**
Cross-platform development allows developers to create software that is compatible with multiple platforms or devices using a single codebase. **One codebase is used to run on multiple platforms**, like developing mobile apps for Android and iOS at once, instead of building separate ones. This process reduces time and resources, inevitably increasing efficiency.

Cross-platform development allows developers to build platforms they may not be familiar with, using their preferred frameworks, such as JavaScript. From a business perspective, cross-platform development leads to **faster time-to-market and lower development and maintenance costs**. These characteristics make it a highly desired method both from a business, and technical perspective.
## **React vs React Native**
React is an open-source JavaScript library used on frontend to build fast and reliable User Interfaces for web applications. It’s very much based on reusable components.

As we mentioned, just like React Native some years later, React was also brought to life by Facebook in 2011 as a direct answer to their scalability problems. It was a time when Facebook ads were growing immensely, and the constant updates to their UI slowed down the platform significantly. React solved this problem, and in 2012, when Instagram was acquired by Facebook, it was also used on the app’s timeline.

React Native, powered by React and developed by Facebook, was a natural consequence of React. It is a mobile framework allowing to build near-native apps using JavaScript.

The bottom line? Both frameworks are **closely related** to each other, but they serve an **entirely different purpose**. React is used for web development, and React Native (which does not use HTML) is used for mobile development.
## **How does React Native work?**
We mentioned React Native utilizes JavaScript to produce the app's interface. Unlike its competitors (e.g. Ionic), **React Native does not rely on webviews**, but the actual real materials provided by native platforms. It has built-in access to the native views and components, and can utilize native-written code and allow the API access to OS-specific features inside the app. The question is - how does that happen exactly?

**React Native uses the concept of “bridge”**, which allows for asynchronous communication between the JavaScript and Native elements - the bridge concept lies at the very heart of React Native’s flexibility. Native and JavaScript elements are completely different technologies, but they are able to communicate.

This type of architecture offers **the benefit of using a lot of OS-native features**, but also comes with important challenges; e.g. constant use of bridges inside the app may significantly slow down its performance. If you’re building an app that involves many events, a lot of data, etc. React Native might not be the best option. More on that below.
## **What’s new for React Native in 2023?**
When choosing React Native you can expect continual improvements and updates that will enhance the performance and speed of your app. Some of the **key 2022 updates** include:

- The **new architecture** has been introduced with the 0.68 version. This includes Fabric Renderer - a new rendering system and TurboModules - a new native modules system. These modules **enhance communication between native code and JavaScript**. Additionally, a new renderer implemented in C++ and core is shared among platforms, making it easier to adopt React Native to different platforms.
- Starting from version 0.70, the **default engine is set as Hermes**, resulting in faster application start time and a smaller APK (Android) file size. While the IPA (iOS) file size may have increased slightly, there is a memory consumption reduction.
### What does it mean for your app?
Basically, the updates make your application is more efficient. Faster loading times and less memory consumption can improve user engagement and satisfaction in the long run.
## **Pros of React Native**
### Code reusability
The effective development for **multiple platforms at once** is the biggest and strongest advantage of React Native. Utilizing the same code base for different platforms carries other benefits: faster development and time-to-market of your app, easier and cheaper maintenance (you take care of one not multiple code bases), and a **smoother onboarding process for new developers** joining the project. The same code may even be used for web and mobile applications if both use React Native.
### Hot Reloading
Hot Reloading feature allows developers to see the changes in their code in real-time and without the need to refresh anything. This seemingly small tweak can tangibly i**mprove the development process as it provides real-time feedback** on anything altered inside the code, resulting in increased productivity. Additionally, it is possible to only reload specific parts of the code, saving time needed for full compilations. 
### Performance 
Compared to other cross-platform development solutions, React Native’s “bridge” concept can be seen as revolutionary. Since React Native apps allow usage of natively written code it is not as laggy as web-based cross-platform solutions. The official claim is that React Native gives “native-like” performance, but it is not necessarily true, the best way to put it is that it gives **“near-native” experience**.
### Cost efficiency
Cost efficiency is the heart and the very reason for cross-platform development. Thanks to reusing code on multiple platforms, you usually need a smaller team to deliver the project. As opposed to native development where you need two separate teams to deliver basically two similar operating products instead of one.
### Growing developer community
React Native is an open source framework, and as of now **its community is thriving and constantly expanding**. We can’t forget the involvement of Facebook, as they are constantly working on improvements and elements widening the framework. What this means for you is that even if you encounter a problem that has not yet been solved in React Native you might find a bunch of people eager to help you out as they are concerned with making the framework more comprehensive and stable.
### Constantly Evolving
React Native is a relatively new framework that has quickly gained popularity in the market. This means it is constantly evolving and improving, and new features and updates are released regularly. We can expect to see faster and more efficient ways to build applications. The active environment makes it a **great choice for the fast-paced mobile app development industry**.
## **Cons of React Native**
### A relatively young technology (but improving with time)
React Native is still relatively new, and as we mentioned earlier, definitely has some limitations, glitches, and issues needing to be addressed. **Some custom modules do not exist in the framework**, which means developers might need more time to build and create their own new ones from scratch. Your partner company or your developers should let you know about this during the app estimation process.
### The need for native mobile developers
The strongest asset of React Native - implementing native code for better performance means that at times React Native developers might find themselves in need of help from native mobile app developers. Same goes for publishing the app in the AppStore and Google Play Store. Typically, native mobile developers are more familiar with the procedure and necessary documentation for a successful launch.

This might not be an issue if you’re cooperating with an agency, where there are already native mobile developers that could give the React Native team a hand. But it is definitely something to consider when you’re working solely with your own cross-platform team.
### React Native does not go well with complex designs & interactions
The React Native’s performance pales when confronted with complicated UI design decisions, complex animations, and heavy interactions. Once again, this is because of the bridge concept - all native modules have to communicate with the JavaScript part of the app, and too many of such interactions may slow down the app significantly, making it laggy and simply giving a bad experience.
### Reliance on Facebook
Relying on a third-party open-source technology has its cons on its own. If Facebook decides to step down from using the technology it might cause others to move back from it. As of now, nothing suggests this turn of events: **Facebook utilizes React Native in their main Facebook app**, the Ads Manager app, Facebook Analytics, and Instagram. The framework’s community is constantly expanding and new big companies are jumping into the game.

Nonetheless, this is something to be mindful of. Native technologies offer much more support and backward compatibility in this respect, compared to any cross-platform solution.
### Near-native performance is still lesser than native
We’ve discussed the React Native performance as superior to other cross-platform solutions available, but it is still somehow slower compared to the native app development. The React Native’s impact on your app’s performance is best discussed with your development team. For the majority of the apps available, it is a small, almost unnoticeable bump, which can, however, grow if the app is dealing with a lot of data or “bridges”.

- **Additional read**: if you're looking for a more [comprehensive look at React Native vs. Native app development](https://www.elpassion.com/blog/react-native-vs-native-app-development).
## **How popular is React Native?**
Many major companies like Facebook, Airbnb, and Instagram use React Native for developing their mobile apps. Its popularity is also shown by a large and active developer community, and constantly growing numbers of packages and libraries available. Those resources allow developers to reduce development time even more.

Beyond the browser
# The Web Beyond Browsers
Web standards aren’t exclusively about facilitating cross-browser consistency. The standardization of web platform APIs beyond the browser is coming, and I’m here for it.

Here’s a few links that have been solidifying this idea in my head as of late.

First: last week, Ryan Dahl (creator of Node.js and now Deno) posted an article titled [“JavaScript Containers”](https://tinyclouds.org/javascript_containers).

*Technology is difficult to predict, but certainly the World Wide Web will be here in 10 years. Every passing day sees more and more human infrastructure tied together via web apps - the web is eating the world. If you believe the web will be here in 10 years, then certainly the standards that make up the web - HTTP, HTML, CSS, JavaScript - will be here.*

This is why I think [my prediction for the web](https://blog.jim-nielsen.com/2022/web-predictions-on-a-whim/) remaining mostly the same (but enhanced!) is a solid one. More and more stuff is going to accrete on top of the existing, standardized [layers of technology](https://adactio.com/articles/16251) which makeup the web. HTTP, HTML, CSS, JavaScript, they’re going to be around for a long while. They’re embedded in everything we do. And JavaScript is one particular interesting space of development in this stack.

*The web is the fundamental medium of human information. JavaScript is unlike other programming languages in that it is deeply tied into this infrastructure.*

So what developments are happening in JavaScript besides new and standardized APIs across browsers?

*There is a new higher level container emerging for server software: the JavaScript sandbox itself.*

*This container isn’t meant to address the same breadth of problems that Linux containers target. Its emergence is a result of its simplicity. It minimizes the boilerplate for web service business logic. It shares concepts with the browser and reduces the concepts that the programmer needs to know…*

*In this emerging server abstraction layer, JavaScript takes the place of Shell. It is quite a bit better suited to scripting than Bash or Zsh. Instead of invoking Linux executables, like shell does, the JavaScript sandbox can invoke Wasm*

On top of all that, there’s the benefit of universality:

*Every web engineer already knows JavaScript browser APIs. Because the JS container abstraction is built on the same browser APIs, the total amount of experience the engineer needs is reduced. The universality of Javascript reduces complexity.*

Yes! As Ryan says, “the future of scripting languages is browser JavaScript”. Standardizing on this future is now an all-important task ahead of us.

*The fundamental mistake of Node.js was diverging from the browser as new APIs were standardized, inventing too much. In 2010, we didn’t have ES modules, but once it was standardized it should be been brought into Node. The same can be said for promises, async/await, fetch, streams, and more. Antiquated non-standard bits like CommonJS require, package.json, node\_modules, NPM, the global process object will ultimately either be standardized and added to the browser or supplanted by web-aligned replacements.*

I think the same way people like [Zeldman](https://en.wikipedia.org/wiki/Jeffrey_Zeldman) helped surface the need and importance of building for browsers with web standards, we’re seeing the same thing happen for browser-adjacent technologies, like servers. Bet on standards!

Which leads me to today’s announcement of the “Web-interoperable Runtimes Community Group (WinterCG)”. From [the Deno blog](https://deno.com/blog/announcing-wintercg):

*when using Deno, you aren't learning new platform specific APIs or functionalities, but rather you are investing in your knowledge of the largest, and most important platform in the world: the web.*

*It's not all sunshine and rainbows, though. Many web platform APIs were designed with only the browser in mind, and not server side runtimes. This means that when server side runtimes implement these APIs, they sometimes have to diverge subtly from the browser implementations and specifications, so the API becomes useful on the server. A great example of this is* fetch*: the API surface itself works fine on servers, but only when CORS is skipped, users can manually handle redirects, and full duplex HTTP streams are supported.*

Indeed, there are tricky divergences for APIs originally made for browsers which are now being ported to server environments. Personally, I learned about these deep-rooted nuances of fetch the hard way: through trial and errors while [trying to make a CORS proxy](https://blog.jim-nielsen.com/2020/a-cors-proxy-with-netlify/) on the server and running into [redirect status codes](https://blog.jim-nielsen.com/2021/fetch-and-3xx-redirect-status-codes/).

*These subtle differences in API behavior exist for all server side implementations of fetch, but are often not well documented, and not consistent across runtimes. To fix this, engineers from Deno, Cloudflare, and a couple of other companies came together to discuss how we could solve this problem. We want to make server side runtimes consistent and compatible with each other...*

*The goal of this new W3C community group is to promote runtimes supporting a comprehensive unified API surface that JavaScript developers can rely on regardless of the runtime they are using: be it browsers, servers, embedded applications, or edge runtimes.*

I love the emphasis on surfacing these bumps in web platform APIs (depending on runtime) and working to smooth them over. I believe it helps everyone grow in their knowledge and expertise of the web over bespoke third-party abstractions.

(Shameless plug: Remix [adapters](https://remix.run/docs/en/v1/other-api/adapter) polyfill these divergences with [the goal to one day be no longer necessary](https://twitter.com/ryanflorence/status/1523653395038449665).)

The web is, indeed, eating the world. And it’s technologies are quickly becoming the foundation of everything we do (even [native apps in macOS are using web views](https://blog.jim-nielsen.com/2022/inspecting-web-views-in-macos/)) — esepecially JavaScript. The goal, it seems, is no longer isomorphic JavaScript that runs on the client and the server but rather (as [I heard on devMode.fm](https://blog.jim-nielsen.com/2022/notes-from-michael-jackson-devmode-fm/)) Megamorphic JavaScript: JS that runs in the browser, on the server, in an isolate, in a service worker, or in a container. In short: everywhere!





References :

\- [https://home.cern/science/computing/birth-web/short-history-web](https://l.facebook.com/l.php?u=https%3A%2F%2Fhome.cern%2Fscience%2Fcomputing%2Fbirth-web%2Fshort-history-web%3Ffbclid%3DIwAR3_LcSx5ADSkATSoAKxKfbT8iNcjgdRuhftEkLSVgSBsYQWdxI9RxcgtGg&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ)

`		`-[https://gist.github.com/rasheedsaqib/be2084922356df4d3d61500e66177e58](https://l.facebook.com/l.php?u=https%3A%2F%2Fgist.github.com%2Frasheedsaqib%2Fbe2084922356df4d3d61500e66177e58%3Ffbclid%3DIwAR1Cd5o-p_sB-V5n-jKgyDjAz5sd7b9Kp66mpAmc6wBKNNHb4AbSZt8sacU&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ)

`		`- [https://massivepixel.io/blog/why-react/](https://l.facebook.com/l.php?u=https%3A%2F%2Fmassivepixel.io%2Fblog%2Fwhy-react%2F%3Ffbclid%3DIwAR301IMPzmEnPduZ7KdVDxNy50nxxDlLdm2er7-W5zEazamu1qk_0ff8qQY&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ)

`		`- [https://www.creative-tim.com/blog/educational-tech/benefits-frameworks-development/#:~:text=Benefits%20of%20Using%20Web%20Development%20Frameworks%201%201.,Improves%20Database%20Proficiency%20...%205%205.%20Reinforces%20security](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.creative-tim.com%2Fblog%2Feducational-tech%2Fbenefits-frameworks-development%2F%3Ffbclid%3DIwAR0UZ6pgvdYz9ERNte45rj4Xpmht29p3oFbGmkAsULZuTQYXPf4uPggc-0E%23%3A~%3Atext%3DBenefits%2520of%2520Using%2520Web%2520Development%2520Frameworks%25201%25201.%2CImproves%2520Database%2520Proficiency%2520...%25205%25205.%2520Reinforces%2520security&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ)

`		`- [https://legacy.reactjs.org/docs/design-principles.html](https://l.facebook.com/l.php?u=https%3A%2F%2Flegacy.reactjs.org%2Fdocs%2Fdesign-principles.html%3Ffbclid%3DIwAR0pAJ3seype2DHK-9ne0sP4Yu0MLsCZCCX6AIYvvMtAbHzLGRjX9axnPHQ&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ) 

`		`- [https://www.linkedin.com/pulse/reacts-rendering-rerendering-reconciliation-explained-shourav-rahman](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.linkedin.com%2Fpulse%2Freacts-rendering-rerendering-reconciliation-explained-shourav-rahman%3Ffbclid%3DIwAR1-_f3plQFunVztAsiOr2vdz-4sDFsZmVdfevKDvsHNnJcFEzCybAZ57NQ&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ) 

`		`- [https://www.geeksforgeeks.org/dom-document-object-model/](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.geeksforgeeks.org%2Fdom-document-object-model%2F%3Ffbclid%3DIwAR10sPZMKm_OqL3H6FKxhk742vV-UI_OSD7QItUKUF-BHFMr7eh_DjpZE3I&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ) 

`		`- [https://www.geeksforgeeks.org/reactjs-virtual-dom/](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.geeksforgeeks.org%2Freactjs-virtual-dom%2F%3Ffbclid%3DIwAR1lHT7_EzuoKUei3_KGpSoCSSoDa2E7dTEm02qNpfo1fUvAZBkB68pnykQ&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ) 

`		`- [https://www.scaler.com/topics/react/virtual-dom-in-react/](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.scaler.com%2Ftopics%2Freact%2Fvirtual-dom-in-react%2F%3Ffbclid%3DIwAR2ZymOjDWuGJLbv2bsUFDjH2raBbgUIyqeNkgDNBocbUIqrvU4PROdmNlY&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ) 

`		`- [https://dev.to/spiceydev/understanding-the-virtual-dom-in-react-enhancing-performance-and-efficiency-1eje](https://l.facebook.com/l.php?u=https%3A%2F%2Fdev.to%2Fspiceydev%2Funderstanding-the-virtual-dom-in-react-enhancing-performance-and-efficiency-1eje%3Ffbclid%3DIwAR33B_d1HbdxjMToXue9SKpgm0Eeg-gJyH9Fq5I4mE0O-0qz6HFL2eF_R6w&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ) 

`		`- [https://www.upgrad.com/blog/jquery-vs-react/](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.upgrad.com%2Fblog%2Fjquery-vs-react%2F%3Ffbclid%3DIwAR3zOo6iy4-nvG41g0qLEf9NEvvh2qwkxpP4Dap_Y5kwhAgasd2Sk26zh0w&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ) 

`		`- [https://www.elpassion.com/blog/what-is-react-native-and-when-to-use-it#:~:text=React%20Native%20is%20an%20open-source%20JavaScript%20framework%2C%20designed,brings%20all%20its%20glory%20to%20mobile%20app%20development](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.elpassion.com%2Fblog%2Fwhat-is-react-native-and-when-to-use-it%3Ffbclid%3DIwAR3M48739DG54mdJzt0raLqrbwQrZ5Si80gwGT_HZayOFLakBwdgUVgZH3k%23%3A~%3Atext%3DReact%2520Native%2520is%2520an%2520open-source%2520JavaScript%2520framework%252C%2520designed%2Cbrings%2520all%2520its%2520glory%2520to%2520mobile%2520app%2520development&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ).

`		`- [https://www.lambdatest.com/blog/cross-browser-compatibility-and-react-js-web-apps/](https://l.facebook.com/l.php?u=https%3A%2F%2Fwww.lambdatest.com%2Fblog%2Fcross-browser-compatibility-and-react-js-web-apps%2F%3Ffbclid%3DIwAR0pAJ3seype2DHK-9ne0sP4Yu0MLsCZCCX6AIYvvMtAbHzLGRjX9axnPHQ&h=AT3wq10f5_NL2GnSvZBn-OSIhclP7UtE6xt3khDtAStXgP23fPNx_CMtB3JvG_LplIFZBooatyVhuzFvQjovtKr4caWLuXzFZ8InZahHxzO17yOqlnYfjoeiAJO2NmOJqhdwcQ)

`		`- https://blog.jim-nielsen.com/2022/the-web-beyond-browsers/
