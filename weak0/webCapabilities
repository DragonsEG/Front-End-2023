 WebCapabilities
Introduction about web capabilities
We want to close the capability gap between the web and native and make it easy for developers to build great
experiences on the open web. We strongly believe that every developer should have access to the capabilities they
need to make a great web experience, and we are committed to a more capable web.
There are, however, some capabilities—like file system access and idle detection—that are available to native but
aren't available on the web. These missing capabilities mean that some types of apps can't be delivered on the
web, or are less useful.
We will design and develop these new capabilities in an open and transparent way, using the existing open web
platform standards processes while getting early feedback from developers and other browser vendors as we
iterate on the design, to ensure an interoperable design
How does a web application work?
The web application server processes the client requests and sends back a response. The requests are usually for
more data or to edit or save new data. For example, if the user clicks on the Read More button, the web
application server will send content back to the user
Why are web applications important?
Web applications prioritize responsive interactions with users while still delivering content through a network and
the internet. Many businesses prefer web applications to websites when gathering data for their marketing plans
and developing products or services that generate revenue
What is web application development?
Web application development describes the process of designing, building, testing and deploying web-based
applications that will be installed on remote servers and delivered to users or customers via the internet
What is the difference between a website and a web application?
A website is a series of webpages that are typically accessed through a web browser and are hosted on a web
server. A web application is a software program that is accessed through a web browser and runs on a web server
Is Facebook a web application?
Web applications are websites with functionality and interactive elements. Gmail, Facebook, YouTube, Twitter, etc.
are all web apps that are dynamic, and built for user engagement
What programming language is used for web applications?
Several programming languages can be used for web development. These include Python, Java, PHP, HTML, and
lots more. Each language used can be broadly categorized into front and back-end languages
What language is used in web design?
A web developer should know these three main programming languages: HTML, CSS, and JavaScript
What are two web applications?
Commonly used web applications can include webmail, online calculators or e-commerce shops
Is Netflix a web application?
Netflix is a subscription-based streaming service that allows our members to watch TV shows and movies on an
internet-connected device. Depending on your plan, you can also download TV shows and movies to your iOS,
Android, or Windows 10 device and watch without an internet connection
What is web application architecture?
Web application architecture describes the relationships between databases, servers, and applications in a
system. It determines how the functionality and logic of a system are distributed between server-side and clientside
What is web application components?
All web-based database applications have three primary components: A web browser (or client), a web application
server, and a database server. Web-based database applications rely on a database server, which provides the
data for the application
What are the similarities between website and web application?

Both websites and web applications run in browsers, both require access to the internet, both have a front end
and a back end written in the same programming languages. What is more, they both possess such attributes as
interactivity, integration, and authentication
What is web app domain?
app domains are, according to Gandi.net and other Resellers, "a security-focused space, meaning that HTTPS is
required for all websites." This is accomplished by including the . app top-level domain on the HSTS preload list,
making HTTPS required on all connections to . app websites
What are the four components of web?
So now, we're going to talk about the components of website design. So, there's four main areas we're going to
cover in this section. Architecture, design, content, and optimization. So, with architecture, there's a lot of steps
involved, and this is kind of the bones, the house that your website is built on
How to create a web page?
Build and manage your
Step 1: Get a domain name and URL. It's important to choose a good domain name. ...
Step 2: Set up an email address to match your domain name. ...
Step 3: Find a web hosting company. ...
Step 4: Design your website. ...
Step 5: Build your website. ...
Step 6: Add and manage your website content. ...
Step 7: Publish your website.
Resources
https://www.youtube.com/watch?v=O1E91eWGkTA&list=WL&index=4
https://codelabs.developers.google.com/codelabs/web-capabilities#0
https://aws.amazon.com/what-is/web-application/
https://www.sumologic.com/glossary/web-application-development/
https://wesrom.com/insights/engineering-insights/website-vs-web-application-what-should-you-choose-wesrom/
https://medium.com/@essentialdesign/website-vs-web-app-whats-the-difference-e499b18b60b4
https://loopstudio.dev/best-languages-for-web-development/
https://payu.in/blog/best-web-designing-language-to-build-websites/
https://help.netflix.com/en/node/412


Web capabilities include various aspects, such as:
Web Development:
The ability to design, create, and build web applications using programming languages like HTML, CSS, and
JavaScript. It involves understanding web frameworks, libraries, and tools to develop functional and visually
appealing web interfaces.
Th m O S ’ ,
your web application development requirements, from small-sized to wider-ranged projects. To maintain and
improve our high-quality web apps, we have expertise in various web development technologies.
Creating a complex web application involves technologies from both the server-side and client-side. When we are
talking about web development technologies, it usually means the client-side technologies, which are used to build
and display everything that the end-user interacts with.
The main language of the web is JavaScript, presented on most web pages and web apps on the client-side. This
means that the web technologies are mostly based on JavaScript, while server-side technologies are varied
(.NET, Java, PHP, Ruby, or even server-side JavaScript Node.js).
We will go through some of the most popular and well-known web technologies to figure out which kind of
technologies you need for your project. Orient Software also offers free quotes if you have any concerns or need
help from an IT expert. Do not hesitate and contact us now for all your IT needs.
Progress Web Apps (PWA):
The progressive web application is a type of application software for the web, built using technologies such as
HTML, CSS, and JavaScript. In simpler terms, a progressive web app is a website that looks and feels like an app
instead of a website. Web users can browse on their browser with an URL just like every other website; however,
 h g h x g “ ” hout the need to download and install.
PWA is not limited to either PC or mobile, and they can be implemented both on desktops and mobile devices. To
 g P A, g h g I h ’t, they are
behaving as an app, and they are an example of PWA. There are many popular PWA that we are currently using
daily such as Pinterest, Uber, Starbucks, and Spotify.
Web standards:
Adherence to established guidelines and protocols that define the structure, behavior, and presentation of web
content. Web standards ensure compatibility, accessibility, and consistency across different web browsers and
devices,
are the technologies we use to build websites. These standards exist as long technical documents called
specifications, which detail exactly how the technology should work. These documents are not very useful for
learning how to use the technologies they describe (this is why we have sites like MDN Web Docs), but instead
are intended to be used by software engineers to implement these technologies (usually in web browsers).
For example, the HTML Living Standard describes exactly how HTML (all the HTML elements, and their associated
APIs, and other surrounding technologies) should be implemented.
Web standards are created by standards bodies — institutions that invite groups of people from different
technology companies to come together and agree on how the technologies should work in the best way to fulfill
all of their use cases. The W3C is the best known web standards body, but there are others such as
the WHATWG (who maintain the living standards for the HTML language), ECMA (who publish the standard for
ECMAScript, which JavaScript is based on), Khronos (who publish technologies for 3D graphics, such as WebGL),
and others.
"Open" standards
One of the key aspects of web standards, which TimBL and the W3C agreed on from the start, is that the web (and
web technologies) should be free to both contribute and use, and not encumbered by patents/licensing. Therefore
anyone can write the code to build a website for free, and anyone can contribute to the standards creation
process, where the specs are written.
Because web technologies are created openly, in collaboration between many different companies, it means that
no one company gets to control them, which is a really good thing. You wouldn't want a single company suddenly
deciding to put the entire web behind a paywall, or releasing a new version of HTML that everyone has to buy to
continue making websites, or worse still, just deciding they aren't interested any more and just turning it off.
This allows the web to remain a freely-available public resource.
Don't break the web
Another phrase you'll hear around open web standards is "don't break the web" — the idea is that any new web
technology that is introduced should be backwards compatible with what went before it (i.e. old websites will still
continue to work), and forwards compatible (future technologies in turn will be compatible with what we currently
have). As you go through the learning material presented here, you'll start to learn how this is made possible with
some very clever design and implementation work.
Web APIs:
The utilization of application programming interfaces (APIs) that allow web applications to interact with external
services, retrieve data, and integrate functionality from other web-based systems. Examples include social media
APIs, payment gateways, and mapping services.
In computer programming, an application programming interface (API) is a set of subroutine definitions,
protocols, and tools for building software and applications.
To put it in simple terms, API is some kind of interface which has a set of functions that allow programmers to
access specific features or data of an application, operating system or other services.
Web API as the name suggests, is an API over the web which can be accessed using HTTP protocol. It is a
concept and not a technology. We can build Web API using different technologies such as Java, .NET etc. For
example, Twitter's REST APIs provide programmatic access to read and write data using which we can
integrate twitter's capabilities into our own application.
Why to Choose Web API?
A Web API services are preferable over other services to use with a native application that does not support SOAP
but require web services.
For creating resource-oriented services, the web API services are the best to choose. By using HTTP or restful
service, these services are established.
If you want good performance and fast development of services, the web API services are very helpful.
For developing light weighted and maintainable web services, web API services are really helpful to develop that
service. It supports any text pattern like JSON, XML etc.
The devices that have tight bandwidth or having a limitation in bandwidth, then the Web API services are the best
for those devices.
How to use Web API?
Web API receives requests from different types of client devices like mobile, laptop, etc, and then sends those
requests to the webserver to process those requests and returns the desired output to the client. Web API is a
System to System interaction, in which the data or information from one system can be accessed by another
system, after the completion of execution the resultant data or we can say as output is shown to the viewer.
API provides data to its programmers which is made available to outside users. When programmers decide to
m k m h h , h “ x , ” m ing they publish a portion of the
language they have used to build their program. Other programmers can then extract the data from the
application by building URLs or using HTTP clients to request data from those endpoints.
Server Side: A server-side web API is a programmatic interface. It consists of one or more publicly exposed
endpoints. It defines a request-response message system. Mashup is a web application that is a server-side API
that combines several server-side APIs. Webhook is a server-side API that takes input as a uniform resource
identifier.
Client Side: Client Side web APIs target standardized JavaScript bindings. Google created their native client
architecture designed to replace native plug-ins with secure native sandboxed extensions and applications.
Steps to use Web API:
-Most APIs require an API key. Once you find an API you want to play with, look in the documentation for access
requirements. Most APIs will ask you to complete an identity verification, like signing in with your Google account.
Y ’ g q g m h g h API
-The easiest way to start using an API is by finding an HTTP client online, like REST-Client, Postman, or Paw. These
ready-made tools help you structure your requests x g API h h API k Y ’
need to know some of the syntaxes from the documentation, but there is very little coding knowledge required.
-The next best way to pull data from an API is by building a URL from existing API documentation.
Web Design:
Web design refers to the design of websites that are displayed on the internet. It usually refers to the user
experience aspects of website development rather than software development
Web design used to be focused on designing websites for desktop browsers; however, since the mid-2010s, design
for mobile and tablet browsers has become ever-increasingly important.
A web designer works on the appearance, layout, and, in some cases, content of a website. Appearance, for
instance, relates to the colors, font, and images used. Layout refers to how information is structured and
categorized. A good web design is easy to use, aesthetically pleasing, and suits the user group and brand of the
website. Many webpages are designed with a focus on simplicity, so that no extraneous information and
 h m gh A h k g ’ h
wins and fosters the trust of the target audience, removing as many potential points of user frustration as possible
is a critical consideration.
Two of the most common methods for designing websites that work well both on desktop and mobile
are responsive and adaptive design. In responsive design, content moves dynamically depending on screen size; in
adaptive design, the website content is fixed in layout sizes that match common screen sizes. Preserving a layout
that is as consistent as possible between devices is crucial to maintaining user trust and engagement. As
responsive design can present difficulties in this regard, designers must be careful in relinquishing control of how
their work will appear. If they are responsible for the content as well, while they may need to broaden their
skillset, they will enjoy having the advantage of full control of the finished product.
How to design a web page?
Designing a web page involves creating a visual layout and aesthetic.
Start by defining the purpose and target audience of your page.
Understand the type of content and what actions the user will perform on the web page.
Sketch ideas and create wireframes or mockups of the layout.
Select a color scheme, typography, and imagery that align with your brand identity.
Use design software like Figma or Sketch to create the design.
Finally, gather feedback and make necessary revisions before handing off the development design.
I h , m m k h x m H ’ h
Accessibility Matters:
How to learn web design?
To learn web design, start by understanding its fundamental principles, such as color theory, typography, and
layout. Practice designing websites, get feedback, and iterate on your designs. Enhance your skills by taking online
courses, attending workshops, and reading articles.
Consider the Interaction Design Foundation's comprehensive UI Designer learning path for essential skills and
knowledge. If you're interested in expanding your skill set, consider exploring UX design as an alternative. The
article "How to Change Your Career from Web Design to UX Design" on the IxDF Blog offers insightful guidance.
Start your journey today!
Is web design the same as front-end?
Web design and front-end development are related but distinct disciplines. Web design involves creating the visual layout and
aesthetics of a website, focusing on user experience, graphics, and overall look. Front-end development, on the other hand,
involves implementing the design into a functional website using coding languages like HTML, CSS, and JavaScript. While there
is overlap, and many professionals have skills in both areas, web design is more creative, and front-end development is more
technical.
In this Master Class webinar, Szymon Adamiak of Hype4 shares his top tips for smooth designer-developer relationships, based
on years of working as a front-end developer with teams of designers on various projects.
What is a modal in web design?
A modal in web design is a secondary window that appears above the primary webpage, focusing on specific
content and pausing interaction with the main page. It's a common user interface design pattern used to solve
interface problems by showing contextual information when they matter.
What does CMS stand for in web design?
In web design, CMS refers to a Content Management System. It is software used to create and manage digital
content.
UX Design
One popular tool in web design is UX Design, it is a type of art that designs products to perform an accurate user
background. UX design is very deep. UX is more than the web, it is very independent, and its fundamentals can be
applied to many other browsers or apps. Web design is mostly based on web-based things. UX can overlap both
web design and design. UX design mostly focuses on products that are less web based
Web Security:
Y ' h h I ’ h h g h g
 m k ’ h h g h k —it's the main door to your attack
surface.
Front-end security demands have increased a lot over the past decade. There are more sophisticated attacks
taking place against web application front ends these days, whereas in the past most attacks were straightforward,
resulting in easier detection. More recently, attacks have become stealthier, harder to detect, and often
discovered far too late.
Employing proactive techniques, like engaging security from the start and nurturing a healthy cybersecurity culture
within an organization, can help reduce the attack surface of any web application's front end.
Top 10 Front-End Security Risks and Best Practices to Prevent Them Let's look at some popular front-end
security issues, and how you can prevent them with the industry's best practices.
1-Preventing cross-site scripting (XSS) attacks
XSS attacks are one of the largest and most dangerous forms of attack. They're crafted in such a way that they
inject code into a web application, which ends up performing malicious actions when accessed by an end user.
XSS attacks are drawn to a lack of sanitization in a web application's input and output, which can lead to a variety
of attacks.
Clickjacking attacks rank as one of the largest types of attacks under the XSS attack umbrella, as they're simply
performed by replacing legitimate parts of a web page with similar-looking, yet dangerous, elements. For example,
checkout buttons can be replaced with buttons redirecting users to fake banking pages, legitimate download
buttons can be replaced with buttons resulting in malware downloads, and more.
Geolocation stealing
With XSS attacks, an attacker can inject JavaScript libraries, which then execute on the client side—logging the
user's IP address, geolocation and other personal details. These can then be used by the attacker to target the end
user with personalized scams or phishing.
Cryptomining
With code injected by an XSS attack, cryptomining can be performed on end users' devices as well. While it may
already seem to slow down a single device, hundreds or thousands of users visiting a web application every day
means crypto mining scripts running on your web application can unknowingly cause not only slowdowns but also
heating issues on users' devices. This sort of effect on your web application can lead to a negative experience on
their part.
Protection against XSS attacks can be achieved by the proper sanitization of inputs made into your web
application, as well as by filtering inputs correctly. For example, limiting mobile numbers to digits only or not
allowing special characters in names can yield a substantial benefit by preventing most injection attacks on your
web application.
2-DoS (denial of service) attacks
DoS attacks and DDoS attacks on web applications are common. They're also difficult to deal with, as they use a
swarm of compromised systems to make requests to your web application.
DoS attacks, which originate from a single system or small number of them, can often be tackled by simply
blocking the end system's IP address.
DDoS attacks, on the other hand, are more difficult to block. This is because certain DDoS attacks originate from
hundreds or thousands of systems at the same time—meaning they also make multiple thousands or millions of
requests to your web application simultaneously—leading to system strain and a serious slowdown of your web
application
Employing rate-limiting in your web application can prevent these types of attacks. Look to services like
CloudFlare or Imperva, or hardware-based solutions; these can filter such attacks before they reach
their intended target.
3-Preventing cross-site request forgery (CSRF)
CSRF attacks are aimed at tricking users into submitting forms which end up performing a different action from the
one the user wishes to perform.
For example, a user is logged into his banking application and browsing the internet at the same time. The user
then comes across a "Download" button which he clicks on, and instead of actually downloading anything for the
user, that fateful click transfers funds from the user's bank account to the attacker.
CSRF attacks can be prevented by using a token value similar to an md5sum or sha256sum of random characters,
which is generated on every page load and passed to a form via HTTP headers, upon the submission of any form
If the header token value is missing or if there is a token mismatch, the action is not performed and the user
remains safe.
4-Using Content Security Policy (CSP)
Using Content Security Policy is an effective form of XSS attack prevention. It calls for an HTTP flag which informs
your browser about the sources that can be trusted, and included as iFrames within your web application.
Any source or URL not mentioned within the Content Security Policy flag is discarded, and will not be included or
rendered within an iFrame on your web application.
Enabling CSP in your HTTP headers is a worthwhile method of preventing XSS attacks to a large extent. And when
combined with X-Frame-Options, it provides a solid defence against XSS attacks in general.
5-Using modern frameworks
Often, web application front ends are built using commonly available frameworks. These frameworks make up the
core of your web application's front end, and any security vulnerability within this framework can lead to a
compromise of your web application as a whole.
Using modern and frequently updated frameworks can help boost your web application's security. These
frameworks frequently include built-in authentication handlers and other security features that help standardize
the security practises needed for your web application.
6-Auditing of 3rd-party libraries in use
3rd-party libraries are in use everywhere. They help speed up coding time and make implementation of new
features into your web application that much easier—but any possible vulnerability in these 3rd-party libraries can
impact your web application's overall security as well.
For example, many web applications rely on 3rd-party libraries for handling billing and customer purchases. Any
vulnerability in these billing libraries can cause multiple security issues in your web application, such as the leaking
of user information or redirecting users to phishing domains to capture card details.
Keeping track of and scanning 3rd-party libraries manually can often be tricky for large web applications, but
online vulnerability scanners exist to help this process along, making it straightforward, automated, and ready to
alert you whenever a vulnerability is found.
7-Incorporating security from the start
Web application development generally runs for months if not years. Developers come, developers go, budgets
change, ideas change and projects change direction.
During all these changes, ensuring that your project stays secure is the most important aspect to consider.
Incorporating a security-first approach in your project from the very start ensures that your project will stay secure
no matter what changes come along, as seen in our previous interview Builders vs Breakers: Bridging the gap
Between Software Development and InfoSec with Tanya Janca.
8-Avoiding iFrames where possible
While iFrames make your development process easier by allowing you to incorporate/load other pages/frames in
your existing view, iFrames usage is often used without appropriate X-Frame-Options. Unfortunately, this allows
for clickjacking attacks and the compromise of your web application's integrity.
iFrame-based attacks can be used to play videos, open malicious forms (which look legitimate), and trick users into
downloading malicious content that can lead to a degraded overall experience of your web application.
9-Restricting available Feature Policy
By default, your web application can access or request any feature from your end user's device—while this may be
a nice-to-have during the development stage, if left enabled it can lead to attackers exploiting your web
application and using these unrestricted feature flags/policies to ask end users' devices to enable certain features
that appear legitimately offered by your web application itself.
Using the Feature-Policy HTTP header is ideal for preventing such requests from originating from your web
application.
For example, setting the following Feature-Policy will alert the end users' web browsers to not enable these
features, even if requested by your web application:
"Feature-Policy": camera 'none'; microphone 'none';
10-Ensuring CDN-pulled libraries undergo subresource integrity checks
Also critical is checking whether libraries loaded via 3rd-party CDNs are intact and untouched. Many web
applications load libraries off 3rd-party CDNs for quicker loading of pages and better overall performance, but if
these libraries are compromised via MITM attacks or if the CDN itself is compromised, it's possible to load bad
code into your web application on the user side, leading to a poor experience.
The above code loads the popular Bootstrap CSS library but includes an integrity parameter with a checksum,
which can be verified by your browser. This ensures that if the CDN is compromised and the CSS file is modified,
the integrity checksum will not match and the file will not render in your user's browser.
At the expense of a poorly rendered page (at most), this will help protect your web application's reputation and
security, while keeping your user safe as well.
Front-end security covers only part of the surface
The security game doesn't end when you finish hardening your front-end security checklist, it's only the beginning.
Your attack surface is a much larger area that must be analyzed and secured properly.
By using tools like Attack Surface Intelligence, you'll be able to analyze other aspects of your backend security,
such as:
Open ports
Exposed databases
Dev and staging subdomains
Old and unused digital assets
Newly observed hostnames
Permission:
In the context of front-end web development, permissions refer to the ability of a web application to request and
obtain user consent to access certain features or resources of the user's device or browser. These permissions
ensure that user privacy and security are respected while providing web applications with necessary access to
perform certain tasks.
Here are some common types of permissions in front-end web development:
1. Geolocation Permission: Web applications can request permission to access the user's geographical location.
This permission allows the application to provide location-based services, such as displaying nearby points of
interest or providing personalized content based on the user's location.
2. Camera and Microphone Permission: Web applications that require access to the user's camera or microphone,
such as video conferencing or photo capture applications, need to request permission before accessing these
devices. This ensures that the user's privacy is protected, and their camera and microphone are not accessed
without their consent.
3. Notifications Permission: Web applications can request permission to display browser notifications to the user.
These notifications can be used to provide updates, alerts, or reminders even when the web application is not
actively open in the browser.
4. Clipboard Permission: Access to the user's clipboard allows web applications to read or write data from or to
the clipboard. This permission is commonly used for tasks like copying text or sharing content between the web
application and other applications.
5. File System Access Permission: Some web applications may need to access the user's local file system to read or
write files. This permission allows the application to interact with files on the user's device, such as uploading or
downloading files.
6. Device Motion and Orientation Permission: Web applications can request permission to access device motion
and orientation data. This permission enables applications to respond to device movements or changes in
orientation, which can be useful for tasks like creating interactive games or augmented reality experiences.
7. Push Notifications Permission: Web applications can request permission to send push notifications to the user's
device. This permission allows the application to send real-time updates or messages to the user, even when the
web application is not actively open in the browser.
It's important to note that permissions are typically handled by the browser, and web applications must request
these permissions through appropriate APIs provided by the browser. Users have the ability to grant or deny these
permissions, and modern browsers often provide granular control over permissions, allowing users to manage and
revoke permissions at any time.
When implementing permissions in front-end web development, it's essential to provide clear information to users
about why the application needs specific permissions and how the data will be used to build trust and ensure
transparency. Additionally, handling permission requests and responses gracefully within the application's user
interface is crucial for a positive user experience.
Certainly! Here are some additional details about permissions in front-end web development:
1. Permission APIs: Browsers provide JavaScript APIs that allow web applications to request and handle
permissions. These APIs include methods for requesting permissions, checking the status of permissions, and
handling user responses. Examples of such APIs include the Geolocation API, MediaDevices API (for camera and
microphone access), Notifications API, and Clipboard API.
2. User Consent: Permissions are based on obtaining user consent. When a web application requests a permission,
the browser prompts the user with a dialog or a bar at the top of the browser window, asking for their permission
to grant or deny access. The user has the option to allow or deny the requested permission. In some cases, the
browser may provide a "remember" option to remember the user's choice for subsequent requests.
3. Permission Status: Once a permission is requested, the browser maintains the status of the permission for the
web application. The status can be "granted," "denied," or "prompt" (indicating that the user has not yet made a
decision). Web applications can check the status of a permission to determine if they have the required access.
4. Permission Handling: Web applications should handle permission requests and responses gracefully. This
includes providing clear and concise explanations to users about why the permission is needed and how it will be
used. It's important to communicate the value and benefits the user will receive by granting the permission, while
also respecting their privacy and ensuring data security.
5. Permission Best Practices: When working with permissions, it's important to follow best practices to provide a
good user experience. Some best practices include:
 - Request permissions only when needed: Only request permissions that are essential for the functionality of the
web application. Avoid unnecessary requests that may raise concerns about privacy or security.
 - Explain the purpose clearly: Clearly explain to the user why the permission is required and how it will enhance
their experience. Use simple and user-friendly language to avoid confusion.
 - Provide granular control: If possible, provide options for users to customize or manage permissions within the
application. This allows users to have more control over their data and privacy.
 - Handle permission denials gracefully: If a user denies a permission request, gracefully handle the denial and
provide alternative options or fallback functionality that still allows the user to use the application, albeit with
limited features.
Permissions in front-end web development play a crucial role in ensuring user privacy, data security, and a positive
user experience. By following best practices and respecting user consent, web applications can provide valuable
features and functionality while maintaining user trust.
Web Performance:
Web performance is all about making websites fast, including making slow processes seem fast. Does the site load
quickly, allow the user to start interacting with it quickly, and offer reassuring feedback if something is taking time
to load (e.g. a loading spinner)? Are scrolling and animations smooth? This article provides a brief introduction to
objective, measurable web performance*, looking at what technologies, techniques, and tools are involved in web
optimization.
Web performance is the objective measurement and perceived user experience of a website or application. This
includes the following major areas:
Reducing overall load time: How long does it take the files required to render the website to download on to the
user's computer? This tends to be affected by latency, how big your files are, how many files there are, and other
factors besides. A general strategy is to make your files as small as possible, reduce the number of HTTP requests
made as much as possible, and employ clever loading techniques (such as preload) to make files available sooner.
Making the site usable as soon as possible: This basically means loading your website assets in a sensible order so
that the user can start to actually use it really quickly. Any other assets can continue to load in the background
while the user gets on with primary tasks, and sometimes we only load assets when they are actually needed (this
is called lazy loading). The measurement of how long it takes the site to get to a usable start after it has started
loading is called time to interactive.
Smoothness and interactivity: Does the application feel reliable and pleasurable to use? Is the scrolling smooth?
Are buttons clickable? Are pop-ups quick to open up, and do they animate smoothly as they do so? There are a lot
of best practices to consider in making apps feel smooth, for example using CSS animations rather than JavaScript
for animation, and minimizing the number of repaints the UI requires due to changes in the DOM.
Perceived performance: How fast a website seems to the user has a greater impact on user experience than how
fast the website actually is. How a user perceives your performance is as important, or perhaps more important,
than any objective statistic, but it's subjective, and not as readily measurable. Perceived performance is user
perspective, not a metric. Even if an operation is going to take a long time (because of latency or whatever), it is
possible to keep the user engaged while they wait by showing a loading spinner, or a series of useful hints and tips
(or jokes, or whatever else you think might be appropriate). Such an approach is much better than just showing
nothing, which will make it feel like it is taking a lot longer and possibly lead to your users thinking it is broken and
giving up.
Performance measurements: Web performance involves measuring the actual and perceived speeds of an
application, optimizing where possible, and then monitoring the performance, to ensure that what you've
optimized stays optimized. This involves a number of metrics (measurable indicators that can indicate success or
failure) and tools to measure those metrics, which we will discuss throughout this module.
How content is rendered
To effectively understand web performance, the issues behind it, and the major topic areas we mentioned above,
you really should understand some specifics about how browsers work. This includes:
How the browser works. When you request a URL and hit Enter / Return , the browser finds out where the server
is that holds that website's files, establishes a connection to it, and requests the files. See Populating the page:
how the browser works for a detailed overview.
Source order. Your HTML index file's source order can significantly affect performance. The download of additional
assets linked to from the index file is generally sequential, based on source order, but this can be manipulated and
should definitely be optimized, realizing that some resources block additional downloads until their content is
parsed and executed.
The critical path. This is the process that the browser uses to construct the web document once the files have
been downloaded from the server. The browser follows a well-defined set of steps, and optimizing the critical
rendering path to prioritize the display of content that relates to the current user action will lead to significant
improvements in content rendering time. See Critical rendering path for more information.
The document object model. The document object model, or DOM, is a tree structure that represents the content
and elements of your HTML as a tree of nodes. This includes all the HTML attributes and the relationships between
the nodes. Extensive DOM manipulation after the pages has loaded (e.g., adding, deleting, or moving of nodes) can
affect performance, so it is worth understanding how to DOM works, and how such issues can be mitigated. Find
out more at Document Object Model.
Latency. We mention this briefly earlier on, but in brief, latency is the time it takes for your website assets to travel
from the server to a user's computer. There is overhead involved in establishing TCP and HTTP connections, and
some unavoidable latency in pushing the request and response bytes back and forth across the network, but there
are certain ways to reduce latency (e.g. reducing the number of HTTP request you make by downloading fewer
files, using a CDN to make your site more universally performant across the world, and using HTTP/2 to serve files
more efficiently from the server). You can read all about this topic at Understanding Latency.
Web Accessibility:
The Web is fundamentally designed to work for all people, whatever their hardware, software, language, location,
or ability. When the Web meets this goal, it is accessible to people with a diverse range of hearing, movement,
sight, and cognitive ability.
Thus the impact of disability is radically changed on the Web because the Web removes barriers to communication
and interaction that many people face in the physical world. However, when websites, applications, technologies,
or tools are badly designed, they can create barriers that exclude people from using the Web.
Accessibility is essential for developers and organizations that want to create high-quality websites and web tools,
and not exclude people from using their products and services.
What is Web Accessibility ?
Web accessibility means that websites, tools, and technologies are designed and developed so that people with
disabilities can use them. More specifically, people can:
-perceive, understand, navigate, and interact with the Web
-contribute to the Web
Web accessibility encompasses all disabilities that affect access to the Web, including:
auditory
cognitive
neurological
physical
speech
visual
Web accessibility also benefits people without disabilities, for example:
-people using mobile phones, smart watches, smart TVs, and other devices with small screens, different input
modes, etc.
-older people with changing abilities due to ageing
- h “ m ” h k m g
- h “ m ” h gh gh m h h
audio
-people using a slow Internet connection, or who have limited or expensive bandwidth
Manage focus - the location on a page that receives input from the keyboard. Discover how some users navigate website entirely
with the keyboard, and how to optimize their experience.
Dive into the differences between visual UI and semantically designed accessible UI. Add semantic elements to HTML to create
a user interface that works for everyone.
Incorporate CSS styling into your accessible web design and use accessible color schemes to improve accessibility.
Accessibility Standards
The Web Content Accessibility Guidelines (WCAG) was developed by the World Wide Web Consortium (W3C) with
the purpose of setting a series of internationally shared guidelines governing the standards of web content
accessibility to make websites, devices, and content accessible to users with disabilities. Content under the WCAG
refers to web content which is the information on a web page or web application, which includes:
There are two versions of WCAG applied currently: WCAG 2.0 and 2.1. WCAG 2.0 was published in 2008 and
became an ISO standard in 2012. WCAG 2.1 was published in 2018. All requirem (“ ”) m 2 0
are included in 2.1, with a few additional success criteria in 2.1. However, the guidelines are backward-compatible,
meaning that content that conforms to WCAG 2.1 also conforms to WCAG 2.0.
The WCAG forms the basis of most legislation on accessibility across the world. Legislation like the Title III of the
Americans with Disabilities Act (ADA), the Accessibility for Ontarians with Disabilities Act (AODA), etc adopt the
WCAG at level AA as the minimum standard of conformance. Some countries have indirect references to the
WCAG. The European Standard EN 301 549 for the EU Web Accessibility Directive for example, does not explicitly
state its adoption of the WCAG but includes all the requirements from the guidelines.
 CAG’ uccess criteria are categorized into three levels of conformance, Level A, AA, and AAA.
Level A
This covers the most basic requirements of accessibility features and is the minimum degree of accessibility that
must be satisfied. Failure to conform to this level will result in a completely inaccessible website.
Level AA
This level addresses some of the more common barriers to entry for people with disabilities. This is the highest
level of conformance required by most websites as it ensures that the biggest accessibility barriers are removed.
Level AAA
This is the highest level for accessibility under WCAG and it is more difficult to achieve by most sites. Achieving this
level is desirable but not of the utmost necessity.
The Four Principles of Accessibility
The principles of web accessibility are the foundations of content produced for the web and for anyone who wants
to use the web. These principles are known as POUR, which is an acronym that describes functional accessibility:
Perceivable - Perceivability refers to the information and elements of user interface that must be presented in a
manner that can be perceived by the senses and that nothing is left undetectable or invisible. To most web users,
perceivability is based primarily on visuals, but for those that are unable to, sound and touch are used instead.
Operable - Interactive interface elements such as controls, buttons, navigation and more should be operable. This
means that a user must be able to operate interface elements by first identifying them, and for most by physically
 k g, g, g, g F h h ’ h , mm h
other assistive devices like head wands and eye trackers.
Understandable - This means that technology should be clear and consistent in the presentation and format, with
predictable patterns of usage and design. End users should have no issue in comprehending the meaning and
purpose of the information presented in the content while discerning the user flow and operation of the interface.
Robust - Robustness is the ability for content to function reliably by a wide variety of technologies, including
assistive devices.
Mobile Responsiveness:
A mobile responsive website is a website that is capable of adapting its content based on the device it is being
viewed on. The layout and design of a website are generally created for desktop users. However, as the number of
 h m h g , ’ h g become
more versatile to ensure that all users have an equally positive experience.
Why is Mobile Responsiveness Important?
Web applications are created in order to address existing user demand. Hence, it is important to understand the
consumers and then create a product that caters to their needs for better retention.
How to make a Mobile Responsive Website
When creating a mobile responsive website, the general layout of the website and its content both need to be
transformed in order to reproduce the desktop experience on a smaller screen.
In order to create a mobile-responsive website, there needs to be a plan in place from the get-go. While designing
the website, research and take into consideration the requirements to create a responsive web application. Sketch
out the layouts for the site, addressing the difference in screen sizes between different devices.
Additionally, take the style and formatting into consideration. Lastly, think through possible issues that may
surface at a later time regarding responsiveness and try to preemptively address these issues early in the design
process. One of the most essential factors when designing a website to be more mobile-responsive is pondering
over what a potential user would want from the web application.
For example, Mobile users are often very impatient and want the content to load quickly. This makes them prone
to abandoning a website if it takes too long to load, while desktop users are more likely to wait. This means that a
fast loading time would be beneficial when creating a mobile responsive web application.
Frontend Cross-Browser Compatibility
Focusing on frontend cross-browser compatibility allows developers to optimize applications for a wide range of
users, devices, and platforms, thereby enhancing the overall reach and adoption of the application. A reliable and
well-optimized application with cross-browser compatibility can increase user satisfaction, foster brand loyalty,
and contribute to higher conversion rates.
The significance of frontend cross-browser compatibility has been amplified by the rapid growth of internet usage
and the proliferation of diverse devices and platforms. According to data from StatCounter, the four leading web
browsers - Chrome, Safari, Firefox, and Edge - collectively account for more than 96% of global internet usage, with
each platform holding a significant and varying market share. This situation compels frontend developers to
prioritize cross-browser compatibility in order to maximize their application's compatibility, functionality, and
aesthetics for users across all browser platforms.
AppMaster, a groundbreaking no-code platform for creating backend, web, and mobile applications, recognizes
the importance of cross-browser compatibility and incorporates this concept into its comprehensive suite of tools
and features. AppMaster offers users the ability to create visually engaging user interfaces and business logic for
their web applications via an intuitive drag-and-drop interface, while leveraging the Vue3 framework and JS/TS
technology to ensure compatibility with major browsers.
One popular method for achieving frontend cross-browser compatibility is to adhere to web standards and
guidelines, such as those established by the World Wide Web Consortium (W3C). By implementing HTML, CSS, and
JavaScript based on these widely accepted protocols, developers can mitigate the differences between various
browser rendering engines and achieve consistent presentation and performance across platforms.
Another approach for ensuring cross-browser compatibility is to employ responsive web design techniques, which
enable applications to adapt their layout and function based on the user's device, screen size, and browser
capabilities. With responsive design, a frontend developer can create a single, versatile application that
accommodates a wide range of usage scenarios, from desktop to mobile and beyond.
Moreover, frontend developers can utilize various tools and testing environments, such as BrowserStack or Sauce
Labs, to assess their applications for cross-browser compatibility. These tools can emulate different browsers,
devices, and operating systems, enabling the developers to identify and resolve potential compatibility issues
before the application goes live.
In addition, frontend developers should stay up-to-date with the latest browser updates, trends, and emerging
web technologies. This continuous learning process will enable them to adapt their applications to the everchanging digital landscape and ensure that their solutions remain efficient, secure, and compatible with a wide
range of browser environments.
How can I test the website for cross-browser compatibility?
Testing for cross-browser compatibility involves checking your website or web application on different browsers
(like Chrome, Firefox, Safari, and Edge), different operating systems (like Windows, macOS, Linux, iOS, and
Android), and different devices (like desktops, laptops, tablets, and smartphones). This can be done manually or
using automated tools that simulate different environments.
What are some common cross-browser compatibility issues and how can I fix them?
Common issues include differences in CSS interpretation, JavaScript functionality, HTML rendering, and feature
support. These can be fixed by using browser-specific stylesheets, JavaScript feature detection, HTML and CSS
validation, and progressive enhancement techniques.
Are there any tools or services available for automated cross-browser testing?
Yes, there are several tools available for automated cross-browser testing, including Selenium, BrowserStack, and
LambdaTest. These tools allow you to test your website or web application across a range of browsers, operating
systems, and devices
Importance of Cross-Browser Testing in Web Development
I ’ g , h gh Th
brings challenges in ensuring a consistent user experience across different platforms. Cross-browser testing is an
essential practice in m h h h g H ’ h ’
Browser Interpretation: Different browsers interpret code differently, leading to potential discrepancies in how a
website appears and functions. Cross-browser testing ensures consistency across various browsers.
Preventing Functionality or Design Issues: Without thorough testing, a website might work perfectly on one
browser but have issues on another. This inconsistency can lead to a poor user experience and loss of potential
customers.
Considering Mobile Browsing: With the rise of mobile browsing, developers must also consider mobile browsers,
which often have different capabilities and constraints compared to desktop browsers. Cross-browser testing
includes testing on various devices to ensure a seamless experience.
Protecting Reputation I g m h ’
Cross-browser testing helps maintain a professional and reliable online presence.
Web storage :
Web storage, sometimes known as DOM storage (Document Object Model storage), is a standard JavaScript API
provided by web browsers. It enables websites to store persistent data on users' devices similar to cookies, but
with much larger capacity[1] and no information sent in HTTP headers.[2] There are two main web storage types:
local storage and session storage, behaving similarly to persistent cookies and session cookies respectively. Web
Storage is standardized by the World Wide Web Consortium (W3C)[3] and WHATWG,[4] and is supported by all
major browsers.
Purpose
Cookies are intended for communication with servers; they are automatically added to all requests and can be
accessed by both the server and client-side. Web storage falls exclusively under the purview of client-side scripting.
Web storage data is not automatically transmitted to the server in every HTTP request, and a web server can't
directly write to Web storage. However, either of these effects can be achieved with explicit client-side scripts,
allowing for fine-tuning the server's desired interaction.
Local and session storage
The two storages are session storage and local storage and they would be used to handle different situations
Web storage offers two different storage areas—local storage and session storage—which differ in scope and
lifetime. Data placed in local storage is per origin—the combination of protocol, host name, and port number as
defined in the same-origin policy. The data is available to all scripts loaded from pages from the same origin that
previously stored the data and persists after the browser is closed. As such, Web storage does not suffer from
cookie Weak Integrity and Weak Confidentiality issues, described in RFC 6265 sections 8.5 and 8.6. Session storage
is both per-origin and per-instance (per-window or per-tab) and is limited to the lifetime of the instance.
Session storage is intended to allow separate instances of the same web app to run in different windows without
interfering with each other, a use case that's not well supported by cookies
The Session Storage is designed for scenarios where the user is carrying out a single transaction, but could be
carrying out multiple transactions in different windows at the same time.
Delete Web Storage
Storing sensitive data on local machine could be dangerous and could leave a security hole.
The Session Storage Data would be deleted by the browsers immediately after the session gets terminated.
To clear a local storage setting you would need to call localStorage.remove('key'); where 'key' is the key of the
value you want to remove. If you want to clear all settings, you need to call localStorage.clear() method.
WebSocket:
WebSocket is bidirectional, a full-duplex protocol that is used in the same scenario of client-server communication,
unlike HTTP it starts from ws:// or wss://. It is a stateful protocol, which means the connection between client and
server will keep alive until it is terminated by either party (client or server). After closing the connection by either
of the client and server, the connection is terminated from both ends.
L ’ k x m -server communication, there is the client which is a web browser and a server,
whenever we initiate the connection between client and server, the client-server made the handshaking and
decide to create a new connection and this connection will keep alive until terminated by any of them. When the
connection is established and alive the communication takes place using the same connection channel until it is
terminated.
This is how after client-server handshaking, the client-server decide on a new connection to keep it alive, this new
connection will be known as WebSocket. Once the communication link establishment and the connection are
opened, message exchange will take place in bidirectional mode until connection persists between client-server. If
anyone of them (client-server) dies or decide to close the connection is closed by both of the party. The way in
which socket works is slightly different from how HTTP works, the status code 101 denotes the switching protocol
in WebSocket.
When can a web socket be used:
Real-time web application: Real-time web application uses a web socket to show the data at the client end, which
is continuously being sent by the backend server. In WebSocket, data is continuously pushed/transmitted into the
same connection which is already open, that is why WebSocket is faster and improves the application
performance.
For e.g. in a trading website or bitcoin trading, for displaying the price fluctuation and movement data is
continuously pushed by the backend server to the client end by using a WebSocket channel.
Gaming application: In a Gaming application, you might focus on that, data is continuously received by the server,
and without refreshing the UI, it will take effect on the screen, UI gets automatically refreshed without even
establishing the new connection, so it is very helpful in a Gaming application.
Chat application: Chat applications use WebSockets to establish the connection only once for exchange, publishing,
and broadcasting the message among the subscribers. It reuses the same WebSocket connection, for sending and
receiving the message and for one-to-one message transfer.
When not to use WebSocket: WebSocket can be used if we want any real-time updated or continuous streams of
data that are being transmitted over the network. If we want to fetch old data, or want to get the data only once
to process it with an application we should go with HTTP protocol, old data which is not required very frequently
or fetched only once can be queried by the simple HTTP request, so in h , ’ S k
Note: RESTful web services are sufficient to get the data from the server if we are loading the data only once.
2D canvas :
The 2D canvas is a fundamental web capability that allows developers to draw and manipulate graphics on a web
page using JavaScript. It is part of the HTML5 specification and provides a rectangular area, known as the canvas,
on which you can draw shapes, images, text, and animations.
Here are some key features and concepts related to the 2D canvas:
1. Drawing Context: The canvas element provides a drawing context, which is accessed through the JavaScript API.
The drawing context allows you to perform various operations, such as drawing paths, shapes, and images.
2. Coordinate System: The canvas has a coordinate system, where the top-left corner is the origin (0, 0). You can
use this coordinate system to position and manipulate your drawings.
3. Paths and Shapes: The canvas API provides methods for creating paths and drawing shapes like rectangles,
circles, lines, and curves. Paths are a series of connected points that can be stroked (outline) or filled (solid shape).
4. Colors and Styles: You can set different colors and styles for your drawings, such as stroke color, fill color,
transparency, gradients, and patterns.
5. Text Rendering: The canvas allows you to draw text on the screen. You can specify the font, size, style, and color
of the text.
6. Images: The canvas can display images by loading them from external sources or using images already present
on the web page. You can manipulate and draw images onto the canvas.
7. Animation: The canvas enables you to create animations by repeatedly clearing and redrawing the canvas with
different frames, creating the illusion of motion.
8. Event Handling: You can attach event listeners to the canvas to respond to user interactions, such as mouse
clicks or touch events. This allows you to create interactive graphics and games.
The 2D canvas is widely used for various purposes, including data visualization, interactive charts, games, image
editing, and drawing applications. It provides a powerful and versatile toolset for creating dynamic and visually
appealing graphics directly within web browsers.
The CanvasRenderingContext2D interface, part of the Canvas API, provides the 2D rendering context for the
drawing surface of a <canvas> element. It is used for drawing shapes, text, images, and other objects. The
interface's properties and methods are described in the reference section of this page
Canvas API
The Canvas API provides a means for drawing graphics via JavaScript and the HTML <canvas> element. Among
other things, it can be used for animation, game graphics, data visualization, photo manipulation, and real-time
video processing.
The Canvas API largely focuses on 2D graphics. The WebGL API, which also uses the <canvas> element, draws
hardware-accelerated 2D and 3D graphics.
Certainly! Here are some additional details about the 2D canvas:
1. Drawing Operations: The canvas API provides a set of methods to perform various drawing operations. These
include methods for drawing lines, arcs, curves, polygons, and more. You can control the appearance of these
drawings by setting stroke properties (line thickness, color, etc.) and fill properties (color, gradients, patterns).
2. Paths and Path Manipulation: Paths in the canvas are made up of a series of drawing commands such as
moveTo(), lineTo(), arc(), bezierCurveTo(), and more. These commands allow you to define complex shapes and
curves. You can also manipulate paths using methods like closePath(), which closes the current path, and clip(),
which defines a clipping region for subsequent drawings.
3. Transformations: The canvas API provides transformation methods that allow you to scale, rotate, translate, and
skew drawings. These transformations can be applied to individual drawings or the entire canvas, allowing you to
create complex compositions and animations.
4. Image Manipulation: In addition to drawing basic shapes, the canvas can also handle image manipulation. You
can load images onto the canvas using the drawImage() method, which allows you to scale, crop, and position the
image. This opens up possibilities for image editing, photo manipulation, and creating composite images.
5. Pixel Manipulation: The canvas API allows you to access and manipulate individual pixels on the canvas. You can
read and modify pixel values, which enables you to perform pixel-level image processing, apply filters, and create
special effects.
6. Animation and Frame Rendering: The canvas is commonly used for creating animations. By repeatedly clearing
and redrawing the canvas at regular intervals, you can create the illusion of motion. This can be achieved using
techniques like requestAnimationFrame(), which optimizes frame rendering and provides smoother animations.
7. Saving and Restoring States: The canvas API provides methods to save and restore the state of the canvas. This
includes properties like transformation matrix, stroke, fill, and global alpha. Saving and restoring states allows you
to create complex drawings and animations without affecting the previous state.
8. Cross-Browser Compatibility: The 2D canvas is supported by all major web browsers, including Chrome, Firefox,
Safari, and Edge. This ensures that canvas-based applications and graphics can be accessed by a wide range of
users.
9. Performance Considerations: Drawing complex graphics on the canvas can be computationally intensive.
Therefore, it's important to optimize performance by minimizing unnecessary calculations, using efficient
algorithms, and leveraging techniques like caching, pre-rendering, and off-screen rendering when applicable.
The 2D canvas is a powerful tool for creating dynamic and interactive graphics directly within web pages. Its
versatility, combined with JavaScript's programming capabilities, offers developers the ability to build engaging
visual experiences and applications on the web.
IndexedDB :
IndexedDB is a client-side web storage technology that provides a way to store and retrieve large amounts of
structured data in a user's web browser. It is a JavaScript-based database system that allows web applications to
persistently store data locally, even when the user is offline.
Here are some key points about IndexedDB:
1. Object Store and Key-Value Pairs: IndexedDB stores data in an object store, which can be thought of as a
collection of JSON-like objects. Each object in the store has a unique key assigned to it, allowing for efficient
retrieval and modification of data.
2. Indexed Access: One of the main features of IndexedDB is the ability to create indexes on properties within the
objects. These indexes enable efficient querying and retrieval of data based on specific fields or criteria, similar to
database indexes in traditional SQL databases.
3. Asynchronous Nature: IndexedDB follows an asynchronous programming model, which means that operations
like opening a database, adding or retrieving data, and executing queries are performed using asynchronous APIs.
This approach helps prevent blocking the main thread of the web application and ensures a smooth user
experience.
4. Transactions: All operations in IndexedDB are performed within transactions. Transactions ensure data
consistency and integrity by guaranteeing that a set of operations either completes successfully or is rolled back as
a whole. Transactions can be used to add, update, or delete data in the object store.
5. Events and Event-Based Model: IndexedDB uses events extensively to handle database operations and notify the
application about changes or errors. Events such as onsuccess, onerror, and onupgradeneeded are commonly used
to handle database events and perform appropriate actions.
6. Cross-Origin Restrictions: IndexedDB is subject to the same-origin policy, which means that data stored in one
origin's IndexedDB database cannot be directly accessed by code from a different origin. This security measure
helps protect user data and prevent unauthorized access.
7. Storage Capacity: The amount of data that can be stored in an IndexedDB database varies across browsers.
Generally, IndexedDB provides a larger storage capacity compared to other web storage options like cookies or
local storage. However, the actual limit depends on the browser and user's settings.
IndexedDB is commonly used in web applications that require persistent storage, offline capabilities, or the ability
to handle large amounts of structured data. It provides a powerful mechanism for developers to build robust, datadriven web applications that can function even in scenarios where an internet connection is unreliable or
unavailable.
Certainly! Here are some additional details about IndexedDB:
1. Transactions and Durability: In IndexedDB, transactions provide durability and atomicity for database
operations. This means that modifications made within a transaction are durable and survive system crashes or
browser restarts. Transactions can also span multiple operations, ensuring that all changes are applied
consistently.
2. Schema Upgrades: IndexedDB allows for schema upgrades, which means you can modify the structure of the
database over time. Schema upgrades involve changing object stores, adding or removing indexes, or updating
existing data. The `onupgradeneeded` event is used to handle schema upgrades and perform necessary migrations.
3. Querying and Indexing: IndexedDB supports querying data using indexes. Indexes are defined on properties
within the data objects, allowing for efficient retrieval based on specific fields. You can create and use indexes to
perform range queries, filtering, and sorting operations on the data in the object store.
4. Cursors: Cursors provide a way to iterate over the records in an object store or perform more complex queries.
Cursors allow you to navigate through the data sequentially or in specific directions, retrieve matching records,
and perform updates or deletions.
5. Error Handling: IndexedDB provides error handling mechanisms to capture and handle errors that may occur
during database operations. Errors can be triggered by constraints violations, conflicts, quota limits, or other
exceptional conditions. Proper error handling ensures that application logic can respond appropriately to errors
and provide a good user experience.
6. Storage Events: IndexedDB supports storage events that allow applications to be notified of changes made to
the database by other instances of the same application or by different tabs or windows. This feature enables realtime synchronization and collaboration between multiple instances of the application.
7. Cross-Browser Compatibility: IndexedDB is supported by most modern web browsers, including Chrome, Firefox,
Safari, and Microsoft Edge. However, it's important to note that the implementation and behavior of IndexedDB
may have slight differences across browsers, so it's recommended to use libraries or abstractions that handle these
discrepancies for better cross-browser compatibility.
8. IndexedDB vs. Other Web Storage Options: IndexedDB is distinct from other web storage options like cookies,
local storage, or session storage. While cookies are primarily used for storing small amounts of data for
authentication or tracking purposes, local storage and session storage offer simpler key-value storage with lower
capacity than IndexedDB. IndexedDB, on the other hand, provides a more robust database-like storage solution for
structured and larger datasets.
IndexedDB is a powerful client-side storage solution that enables web applications to store and retrieve structured
data efficiently. It's particularly useful for offline functionality, caching, complex data querying, and scenarios
where a larger amount of persistent data needs to be managed within the browser.
Resources :
https://www.orientsoftware.com/technologies/web-technologies/
https://developer.mozilla.org/en-US/docs/Learn/Getting_started_with_the_web/The_web_and_web_standards
https://distantjob.com/blog/web-vs-software-development/
https://www.tutorialsteacher.com/webapi/what-is-web-api
https://www.geeksforgeeks.org/what-is-web-api-and-why-we-use-it/
https://www.interaction-design.org/literature/topics/web-design
https://en.wikipedia.org/wiki/Web_design
https://securitytrails.com/blog/frontend-security-best-practices
https://developer.mozilla.org/en-US/docs/Learn/Performance/What_is_web_performance
https://en.wikipedia.org/wiki/Web_performance
https://www.w3.org/WAI/fundamentals/accessibility-intro/
https://www.udacity.com/course/web-accessibility--ud891
https://monsido.com/web-accessibility
https://appmaster.io/glossary/frontend-cross-browser-compatibility
https://www.romexsoft.com/blog/cross-browser-compatibility-and-testing/
https://en.wikipedia.org/wiki/Web_storage
https://www.tutorialspoint.com/html5/html5_web_storage.htm
https://www.youtube.com/watch?v=69t4zZ7KQ7M
https://www.geeksforgeeks.org/what-is-web-socket-and-how-it-is-different-from-the-http/
https://www.youtube.com/watch?v=gCkyqAjY-pM
https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API
https://frontend.turing.edu/lessons/module-4/indexedDB.html
https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
